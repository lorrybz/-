<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>web后端Django-高潮3form表单</title>
      <link href="/2019/01/10/web-hou-duan-django-gao-chao-3form-biao-dan/"/>
      <url>/2019/01/10/web-hou-duan-django-gao-chao-3form-biao-dan/</url>
      
        <content type="html"><![CDATA[<h3 id="实例背景"><a href="#实例背景" class="headerlink" title="实例背景"></a>实例背景</h3><p>form表单此处的应用实例，当对输入的学生信息要进行验证，如姓名长度，性别验证以及输入的不能为空。通常原始操作是需要些一堆if条件进行验证，而此处是使用form表单对其进行验证</p><h3 id="工程中学生类"><a href="#工程中学生类" class="headerlink" title="工程中学生类"></a>工程中学生类</h3><p>注意姓名，性别，以及头像</p><pre><code>from django.db import models# Create your models here.class Student(models.Model):    s_name = models.CharField(max_length=10,unique=True)    s_age = models.IntegerField(default=20)    s_gender = models.BooleanField(default=0)    create_time = models.DateTimeField(auto_now_add=True)    # auto_now_add   创建时，默认字段赋值为最新的事件    # create_time = models.DateField    updata_time = models.DateTimeField(auto_now=True)    # 修改数据是，自动赋值为更新字段时 的时间。    math = models.DecimalField(max_digits=3,decimal_places=1,null=True)    wuli = models.DecimalField(max_digits=3,decimal_places=1,null=True)    # 存图片地址,数据库中字段类型为varchar    icon = models.ImageField(upload_to=&#39;upload&#39;,null=True)    class Meta:        db_table = &#39;student&#39;</code></pre><h3 id="在html中写出提交即将添加学生的代码"><a href="#在html中写出提交即将添加学生的代码" class="headerlink" title="在html中写出提交即将添加学生的代码"></a>在html中写出提交即将添加学生的代码</h3><p>注意事项：<br>1.：日后再说<br>2.因为要提交图片，需要加入enctype=”multipart/form-data”<br>3.errors.icon.0是用表单校验后如有异常需要解析的异常<br>4.submit提交的是name键以及对应输入的值。</p><pre><code>    &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        {% csrf_token %}        &lt;p&gt;姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;{{ errors.username.0 }}&lt;/p&gt;        &lt;p&gt;性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;{{ errors.gender.0 }}&lt;/p&gt;        &lt;p&gt;图片：&lt;input type=&quot;file&quot; name=&quot;icon&quot;&gt;{{ errors.icon.0 }}&lt;/p&gt;        &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/p&gt;    &lt;/form&gt;</code></pre><h3 id="form表单操作"><a href="#form表单操作" class="headerlink" title="form表单操作"></a>form表单操作</h3><p>在文件夹中创建forms.py之后写入代码<br>注意：此处给出了单独校验性别姓名，以及合在一起校验的方法<br>并且在此处校验之后将会重新赋值，比如将性别改成存入数据库的布尔值0或1；</p><pre><code>from django import formsfrom app.models import Studentclass StuForm(forms.Form):    username = forms.CharField(max_length=10,                               min_length=2,                               required=True,                               error_messages={                                   &#39;required&#39;:&#39;姓名字段必填&#39;,                                   &#39;min_length&#39;:&#39;不能少于两个字符&#39;,                                   &#39;max_length&#39;:&#39;不能超过10个字符&#39;,                               })    icon = forms.ImageField(required=True,                            error_messages={                                &#39;required&#39;:&#39;头像必填&#39;                            })    gender = forms.CharField(required=True,                             error_messages={                                 &#39;required&#39;:&#39;性别必填&#39;                             })    # def clean(self):    #      # 这是校验所有的    #     # 转换性别为1或者是0    #     gender = self.cleaned_data.get(&#39;gender&#39;)    #     if gender == &#39;男&#39;:    #         self.cleaned_data[&#39;gender&#39;] = 1    #     else:    #         self.cleaned_data[&#39;gender&#39;] = 0    #    #     # 校验姓名是唯一的    #     username = self.cleaned_data.get(&#39;username&#39;)    #     stu = Student.objects.filter(s_name=username).first()    #     if stu:    #         raise forms.ValidationError({&#39;username&#39;:&#39;姓名重复&#39;})    #    #     return self.cleaned_data    def clean_username(self):        # 只是校验姓名        username = self.cleaned_data.get(&#39;username&#39;)        stu = Student.objects.filter(s_name=username).first()        if stu:            raise forms.ValidationError(&#39;姓名重复&#39;)        return self.cleaned_data[&#39;username&#39;]    def clean_gender(self):        # 只是检验性别        gender = self.cleaned_data.get(&#39;gender&#39;)        if gender == &#39;男&#39;:            self.cleaned_data[&#39;gender&#39;] = 1        else:            self.cleaned_data[&#39;gender&#39;] = 0        return self.cleaned_data[&#39;gender&#39;]</code></pre><h3 id="校验全部成功后，写入数据库的操作以及跳转操作"><a href="#校验全部成功后，写入数据库的操作以及跳转操作" class="headerlink" title="校验全部成功后，写入数据库的操作以及跳转操作"></a>校验全部成功后，写入数据库的操作以及跳转操作</h3><pre><code>def add_stu_info(request):    if request.method == &#39;GET&#39;:        return render(request,&#39;add_stus.html&#39;)    if request.method == &#39;POST&#39;:        form = StuForm(request.POST,request.FILES)        if form.is_valid():            username = form.cleaned_data[&#39;username&#39;]            icon = form.cleaned_data[&#39;icon&#39;]            # 获取的字段为1或者0            gender = form.cleaned_data[&#39;gender&#39;]            Student.objects.create(s_name=username,                                   icon=icon,                                   s_gender=gender)            return  HttpResponseRedirect(reverse(&#39;app:all_stu&#39;))        else:            errors = form.errors            return render(request,&#39;add_stus.html&#39;,{&#39;errors&#39;:errors})</code></pre><p><strong>分析</strong>：如果请求为GET请求，则跳转到学生创建页面stu_form.html。当用户在学生创建页面中填写的学生姓名、年龄、性别并点击提交后，视图函数将接收POST请求，并做如下的处理。</p><p>接收POST请求，可以分以下三步骤分析：</p><p><strong>步骤1：</strong>在POST请求中，通过请求request中的POST属性获取页面中通过表单form提交的数据，数据中包括姓名name、年龄age、性别sex。</p><p><strong>步骤2：</strong> 使用StudentForm表单验证request.POST中提交的数据。在表单中定义了name、age、sex字段是必填字段，并且姓名的长度不能超过10个字符，如果在页面中没有填写其中任何一个参数，或者姓名字段填写太长，则表单验证不通过。</p><p><strong>步骤3</strong>：判断表单是否验证通过，可以使用is_valid()方法。如果表单验证成功，则返回True，否则返回False。</p><p><strong>步骤4：</strong>如果验证表单成功，则通过Student模型进行数据存储。如果验证失败，则返回stu_form.html页面，并将form参数传递给页面。</p><p><strong>3. 表单的错误提示</strong><br>定义了校验页面中传递参数的StudentForm表单类，并且使用is_valid()方法判断表单校验是否成功。如果is_valid()的结果为False,则表示表单校验失败。form表单验证可以通过使用form.errors查询验证的错误信息。</p><h3 id="删除学生"><a href="#删除学生" class="headerlink" title="删除学生"></a>删除学生</h3><p>当在查看学生信息的页面，可以对学生进行删除的操作</p><h4 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h4><p>在此处html中添加操作列</p><pre><code>        &lt;thread&gt;            &lt;th&gt;编号&lt;/th&gt;            &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;年龄&lt;/th&gt;            &lt;th&gt;性别&lt;/th&gt;            &lt;th&gt;头像&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/thread&gt;</code></pre><h4 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h4><p>在此处添加删除的按钮</p><pre><code>                    &lt;td&gt;&lt;img src=&quot;/media/{{ stu.icon }}&quot;&gt;&lt;/td&gt;                    &lt;td&gt;                        &lt;a href=&quot;{% url 'app:del_stu' stu.id %}&quot;&gt;删除&lt;/a&gt;                    &lt;/td&gt;</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>在查看全部学生的页面中，即可直接操作管理员。</p><pre><code>def del_stu(request,id):    if request.method == &#39;GET&#39;:        Student.objects.filter(pk=id).delete()        return HttpResponseRedirect(reverse(&#39;app:all_stu&#39;))-</code></pre>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web后端Django-高潮2request,responsecookie和session,</title>
      <link href="/2019/01/09/web-hou-duan-django-gao-chao-2request-responsecookie-he-session/"/>
      <url>/2019/01/09/web-hou-duan-django-gao-chao-2request-responsecookie-he-session/</url>
      
        <content type="html"><![CDATA[<h3 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h3><p>当前的项目是为了创建账户登录以及保存在数据库方</p><ul><li>参考高潮1，在templates中创建login.html以及register.html文件。同时拷贝高潮1中的index相关文件到当前文件夹</li><li>使用python manage.py startapp user 创建一个user文件夹。</li><li>同时在setting中添加一个euser，以便在迁移时能够成功。</li><li>在工程文件夹中添加路由<pre><code>path(&#39;user/&#39;,include((&#39;user.urls&#39;,&#39;user&#39;),namespace=&#39;user&#39;)),</code></pre></li><li>在新建的user中的models.py中写入代码，在数据库中创建两张新表<br><code>`</code><br>from django.db import models</li></ul><h1 id="Create-your-models-here"><a href="#Create-your-models-here" class="headerlink" title="Create your models here."></a>Create your models here.</h1><p>class User(models.Model):<br>    username = models.CharField(max_length=10,unique=True)<br>    password = models.CharField(max_length=150,null=False)<br>    crate_time = models.DateTimeField(auto_now_add=True)</p><pre><code>class Meta:    db_table = &quot;user&quot;</code></pre><p>class UserToken(models.Model):<br>    user = models.ForeignKey(User,on_delete=models.CASCADE)<br>    token = models.CharField(max_length=20)</p><pre><code>class Meta:    db_table = &#39;user_token&#39;</code></pre><pre><code>views.py 中写入代码</code></pre><p>import random<br>from django.contrib.auth.hashers import make_password,check_password<br>from django.shortcuts import render<br>from django.http import HttpResponseRedirect<br>from django.urls import reverse<br>from user.models import User, UserToken</p><p>def login(request):<br>    if request.method == ‘GET’:<br>        return render(request,’login.html’)<br>    if request.method == ‘POST’:<br>        username = request.POST.get(‘username’)<br>        password = request.POST.get(‘password’)<br>        user = User.objects.filter(username=username).first()</p><pre><code>    # 校验密码    if user:        if check_password(password,user.password):        # if username == &#39;lorry&#39; and password == &#39;123123&#39;:            res = HttpResponseRedirect(reverse(&#39;user:index&#39;))            s = &#39;1234567890qwertyuiopasdfghjklzxcvbnm&#39;            token = &#39;&#39;            for i in range(20):                token += random.choice(s)            res.set_cookie(&#39;token&#39;,token,max_age=30)            # 保存token到user_token表中            UserToken.objects.filter(user_id=user.id).delete()            UserToken.objects.create(user_id=user.id,token=token)            return res        else:            # 模拟登陆失败            # return render(request,&#39;login.html&#39;)            # 设置cookie            return HttpResponseRedirect(reverse(&#39;user:login&#39;))    else:        msg = &#39;账号未注册&#39;        return render(request,&#39;login.html&#39;,{&#39;msg&#39;:msg})</code></pre><p>def index(request):<br>    if request.method == ‘GET’:<br>        token = request.COOKIES.get(‘token’)</p><pre><code>    # 判断token是否存在，如果不存在说明没有登陆或者登陆失效    if not token:        return HttpResponseRedirect(reverse(&#39;user:login&#39;))    user_token=UserToken.objects.filter(token=token).first()    # user_token判断表中是否存在token值，如果不存在，表示用户没有登陆    if not user_token:        return HttpResponseRedirect(reverse(&#39;user:login&#39;))    return render(request,&#39;index.html&#39;)</code></pre><p>def logout(request):<br>    if request.method == ‘GET’:<br>        res = HttpResponseRedirect(reverse(‘user:login’))</p><pre><code>    # 删除cookie中的键值对    res.delete_cookie(&#39;token&#39;)    return res</code></pre><p>def register(request):<br>    if request.method == ‘GET’:<br>        return render(request,’register.html’)<br>    if request.method == ‘POST’:</p><pre><code>    # 1.接受页面中传递的参数    username = request.POST.get(&#39;username&#39;)    password = request.POST.get(&#39;password&#39;)    password2 = request.POST.get(&#39;password2&#39;)    # 2.实现保存用户信息到user表中    if User.objects.filter(username=username).exists():        msg = &#39;账号已存在&#39;        return render(request,&#39;register.html&#39;,{&#39;msg&#39;:msg})    if password != password2:        msg = &#39;密码不一致&#39;        return render(request,&#39;register.html&#39;,{&#39;msg&#39;:msg})    password = make_password(password)    User.objects.create(username=username,password=password)    # 3.跳转到登陆    return HttpResponseRedirect(reverse(&#39;user:login&#39;)) #这个是跳转    # return render(request,&#39;login.html&#39;)   #这个是渲染页面</code></pre><p>此处使用session<br>def mylogin(request):<br>    if request.method == ‘GET’:<br>        return render(request,’login.html’)<br>    if request.method == ‘POST’:<br>        username = request.POST.get(‘username’)<br>        password = request.POST.get(‘password’)<br>        user = User.objects.filter(username=username).first()<br>        if check_password(password,user.password):</p><pre><code>        # 向cooki中保存键为sessionidde的值        # django-session 表中存的seeeion值        # djanggo-session表中春粗键值对{&#39;username&#39;：username}        request.session[&#39;user_id&#39;] = user.id        return HttpResponseRedirect(reverse(&#39;user:hindex&#39;))    else:        msg = &#39;账号或密码错误&#39;        return render(request,&#39;login.html&#39;,{&#39;msg&#39;:msg})</code></pre><p>def hindex(request):<br>    if request.method == ‘GET’:<br>        if request.session.get(‘user_id’):<br>            user_id = request.session[‘user_id’]<br>            user = User.objects.get(pk = user_id)<br>            print(‘当前登陆系统的人是%s’ % user.username)<br>            return render(request,’index.html’)<br>        else:<br>            return render(request,’login.html’)<br>def mylogout(request):<br>    if request.method == ‘GET’:</p><pre><code>    # 1.删除cookie中sessionid值    # 2.删除Django-session表中的数据    # 3.删除Django-session中session-data中的user_id    #1.清库    # request.session.flush()    # 删除键值对    del request.session[&#39;user_id&#39;]    return HttpResponseRedirect(reverse(&#39;user:mylogin&#39;))</code></pre><pre><code>在urls.py中感谢如代码</code></pre><p>from django.urls import path</p><p>from user import views</p><p>urlpatterns = [<br>    path(‘login/‘,views.login,name=’login’),<br>    path(‘index/‘,views.index,name=’index’),<br>    path(‘logout/‘,views.logout,name=’logout’),<br>    path(‘register/‘,views.register,name=’register’),<br>    path(‘mylogin/‘,views.mylogin,name=’mylogin’),<br>    path(‘hindex/‘,views.hindex,name=’hindex’),<br>    path(‘mylogout/‘,views.mylogout,name=’mylogout’)<br>]<br><code>`</code><br>cookie的诞生<br>cookie不属于http协议范围,由于http协议无法保持状态,但实际情况,我们却又需要“保持状态”,因此cookie就是在这样一个场景下诞生。</p><p>cookie的工作原理是:由服务器产生内容,浏览器收到请求后保存在本地;当浏览器再次访问时,浏览器会自动带上cookie ,这样服务器就能通过cookie的内容来判断这个是”谁”了。</p><p>cookie虽然在一定程度上解决了”保持状态的需求,但是由于cookie本身最大支持4096字节,以及cookie本身保存在客户端，可能被拦截或窃取,因此就需要有一种新的东西,它能支持更多的字节,并且他保存在服务器,有较高的安全性。这就是session。</p><p>问题来了, 基于http协议的无状态特征,服务器根本就不知道访问者是”谁”。那么上述的cookie就起到桥接的作用。<br>我们可以给每个客户端的cookie分配一个唯一 的id ,这样用户在访问时,通过cookie ,服务器就知道来的人是”谁”。然后我们再根据不同的cookie的id ,在服务器上保存一段时间的私密资料,如”账号密码”等等。</p><p>总结而言: cookie弥补了http无状态的不足,让服务器知道来的人是”谁”;但是cookie以文本的形式保存在本地,自身安全性较差;所以我们就通过cookie识别不同的用户,对应的在session里保存私密的信息以及超过4096字节的文本。</p><p>另外，上述所说的cookie和session其实是 共通性的东西,不限于语言和框架</p>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web后端Django-高潮3中间件</title>
      <link href="/2019/01/09/web-hou-duan-django-gao-chao-3-zhong-jian-jian/"/>
      <url>/2019/01/09/web-hou-duan-django-gao-chao-3-zhong-jian-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>面向切面编程AOP中的中间件是一个最好的例子。官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。</p><h4 id="1-中间件Middleware描述"><a href="#1-中间件Middleware描述" class="headerlink" title="1. 中间件Middleware描述"></a>1. 中间件Middleware描述</h4><p>中间件：</p><p>1) 是一个轻量级的，底层的插件，可以介入Django的请求和响应的过程（面向切面编程)</p><p>2) 中间件的本质就是一个python类</p><p>注意：中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。</p><p>思考：</p><p>什么是中间件，在settings.py中有很多的中间件，主要是用来做什么功能的呢，他们处理请求的url的过程在那些阶段呢，一般用来做那些数据的处理呢</p><h4 id="2-中间件类函数描述"><a href="#2-中间件类函数描述" class="headerlink" title="2. 中间件类函数描述"></a>2. 中间件类函数描述</h4><p>在Django项目中，在settings.py中可以查看到已经定义好的中间件，并加入我们自定义的两个中间件。</p><pre><code>MIDDLEWARE = [    &#39;django.middleware.security.SecurityMiddleware&#39;,    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,    &#39;django.middleware.common.CommonMiddleware&#39;,    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,    &#39;utils.middleware.TestMiddlware1&#39;,  # 加载中间件TestMiddlware1    &#39;utils.middleware.TestMiddlware2&#39;,  # 加载中间件TestMiddlware2]</code></pre><p>每个中间件是一个独立的类, 有几下几个方法</p><pre><code>1. process_request(self, request)    执行时机在django接收到request之后, 但仍未解析出url以确定运行哪个视图函数view之前2. process_view(self, request, view_func, view_args, view_kwargs)    执行时机在django执行完request预处理函数并确定待执行的view之后, 但在视图函数view之前    request: HttpRequest对象    view_fun: 是django将要调用的视图函数, 是真实的函数对象本身    view_args: 将传入view的位置参数列表, 不包括request参数    view_kwargs: 将传入view的字典参数3. process_response(self, request, response)    该方法必须返回HttpResponse对象, 可以是原来的, 也可以是修改后的    调用时机在django执行完view函数并生成response之后, 该中间件能修改response的内容, 常见用途比如压缩内容    request是request对象    response是从view中返回的response对象4. process_exception(self, request, exception)    默认不主动调用，该方法只有在request处理过程中出了问题并且view函数抛出了一个未捕获的异常才会被调用, 可以用来发送错误通知, 将相关信息输出到日志文件, 或者甚至尝试从错误中自动恢复    参数包括request对象, 还有view函数抛出的异常对象exception    必须返回None或HttpResponse对象5. process_template_response(self, request, response)    默认不主动调用，在视图执行render()返回后进行调用，必须返回None或HttpResponse对象</code></pre><p>以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。</p><h4 id="3-process-request-函数"><a href="#3-process-request-函数" class="headerlink" title="3. process_request()函数"></a>3. process_request()函数</h4><p>process_request方法中有一个request参数，其表示请求。该方法中可以返回None或不用返回任何参数，或返回HttpResponse对象。如果返回None或不返回任何参数则表示继续执行其余中间件，如果是返回HttpResponse对象则直接返回HttpResponse对象给客户端，而不再执行视图函数。</p><p>访问index路由地址，在Pycharm的控制台中可以打印如下的内容：<br>​<br>    test1 process_request<br>    test2 process_request<br>    index views</p><p>从结果中可以发现，中间件TestMiddlware1的process_request比TestMiddlware2的process_request方法先执行，并且视图函数是最后才执行。<br>通过以上的打印可以得出总结：</p><pre><code>1）    中间件的process_request方法是按照在MIDDLEWARE中定义的先后顺序执行的。2）    视图函数在process_request方法执行之后才执行。</code></pre><h4 id="4-process-response-self-request-response-函数"><a href="#4-process-response-self-request-response-函数" class="headerlink" title="4. process_response(self, request, response)函数"></a>4. process_response(self, request, response)函数</h4><p>process_ response方法中两个参数，一个是请求request参数，一个是响应response参数，该response参数就是视图函数返回的HttpResponse对象。</p><p>修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：</p><pre><code>class TestMiddlware1(MiddlewareMixin):    def process_request(self, request):        print(&#39;test1 process_request&#39;)    def process_response(self, request, response):        print(&#39;test1 process_response&#39;)        return responseclass TestMiddlware2(MiddlewareMixin):    def process_request(self, request):        print(&#39;test2 process_request&#39;)    def process_response(self, request, response):        print(&#39;test2 process_response&#39;)        return response</code></pre><p>访问inde路由地址，在控制台中可以打印如下的内容: </p><pre><code>test1 process_requesttest2 process_requestindex viewstest2 process_responsetest1 process_response</code></pre><p>从结果中可以发现，中间件的process_request在访问视图函数之前执行，而process_reponse在视图函数之后执行。并且从执行顺序中可以得出以下结论:</p><pre><code>1）    多个中间件的process_request的执行顺序是按照在MIDDLEWARE中定义的先后顺序执行的。2）    多个中间件的process_response的执行顺序是按照MIDDLEWARE中定义的顺序逆序执行的。也就是说第一个中间件的process_request先执行，而第一个中间件的process_response最后执行。3）    视图函数在process_request之后执行。4）    视图函数在process_response之前执行。5）    process_response必须返回响应对象。</code></pre><h4 id="5-process-view-self-view-func-view-args-view-kwargs-讲解及处理流程"><a href="#5-process-view-self-view-func-view-args-view-kwargs-讲解及处理流程" class="headerlink" title="5.    process_view(self, view_func, view_args, view_kwargs) 讲解及处理流程"></a>5.    process_view(self, view_func, view_args, view_kwargs) 讲解及处理流程</h4><p>该方法接收四个参数:</p><pre><code>请求requestview_func: 即将被执行的函数view_args：传递给视图函数的列表参数view_kwargs：传递给视图函数的字典参数</code></pre><p>修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：<br>​<br>    class TestMiddlware1(MiddlewareMixin):</p><pre><code>    def process_request(self, request):        print(&#39;test1 process_request&#39;)    def process_response(self, request, response):        print(&#39;test1 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test1 process_view&#39;)class TestMiddlware2(MiddlewareMixin):    def process_request(self, request):        print(&#39;test2 process_request&#39;)    def process_response(self, request, response):        print(&#39;test2 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test2 process_view&#39;)</code></pre><p>访问index路由地址，在控制台中可以打印如下的内容: </p><pre><code>test1 process_requesttest2 process_requesttest1 process_viewtest2 process_viewindex viewstest2 process_responsetest1 process_response</code></pre><p>从结果中可以发现，中间件中的process_view方法在视图函数之前执行，在process_request方法之后执行，process_view执行的顺序按照MIDDLEWARE中定义中间件的顺序执行的。并且从执行的结果中可以得出以下结论:<br>​<br>    1）    process_request执行后才执行process_view<br>    2）    视图函数在process_view方法执行后执行<br>    3）    process_view方法在process_response方法之后执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行</p><h4 id="6-process-template-response-self-request-response-讲解及处理流程"><a href="#6-process-template-response-self-request-response-讲解及处理流程" class="headerlink" title="6.    process_template_response(self, request, response) 讲解及处理流程"></a>6.    process_template_response(self, request, response) 讲解及处理流程</h4><p>该方法中接收两个参数，一个是请求request，一个是响应response，该响应response由视图函数产生。process_template_response方法默认是不执行的，只会在视图函数返回对象有一个render方法时才会被调用。</p><p>修改index视图函数<br>    def index(request):<br>        print(‘ index views’)<br>        def index_render():<br>            return render(request, ‘index.html’)</p><pre><code>    rep = HttpResponse()    rep.render = index_render    return rep</code></pre><p>修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：</p><pre><code>class TestMiddlware1(MiddlewareMixin):    def process_request(self, request):        print(&#39;test1 process_request&#39;)    def process_response(self, request, response):        print(&#39;test1 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test1 process_view&#39;)    def process_exception(self, request, exception):        print(&#39;test1 process_except&#39;)    def process_template_response(self, request, response):        print(&#39;test1 process_template_response&#39;)        return responseclass TestMiddlware2(MiddlewareMixin):    def process_request(self, request):        print(&#39;test2 process_request&#39;)    def process_response(self, request, response):        print(&#39;test2 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test2 process_view&#39;)    def process_exception(self, request, exception):        print(&#39;test2 process_except&#39;)    def process_template_response(self, request, response):        print(&#39;test2 process_template_response&#39;)        return response</code></pre><p>访问index路由地址，在控制台中可以打印如下的内容: </p><pre><code>test1 process_requesttest2 process_requesttest1 process_viewtest2 process_viewindex viewstest2 process_template_responsetest1 process_template_responsetest2 process_responsetest1 process_response</code></pre><p>从结果中可以得出以下结论:</p><pre><code>1）    process_template_response在视图函数执行完后。并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。2）    process_response方法是最后执行的，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。</code></pre><h4 id="7-process-exception-self-request-exception-讲解及处理流程"><a href="#7-process-exception-self-request-exception-讲解及处理流程" class="headerlink" title="7.    process_exception(self, request, exception) 讲解及处理流程"></a>7.    process_exception(self, request, exception) 讲解及处理流程</h4><p>该方法中接收两个参数，一个是请求request，一个是异常exception，该exception是视图函数产生的异常Exception对象。process_exception方法默认是不执行的，只会在视图函数出现异常的情况才会执行。</p><p>修改index视图函数，使得index方法抛出一个异常:</p><pre><code>def index(request):    if request.method == &#39;GET&#39;:        print(&#39;index views&#39;)        1/0        return HttpResponse(&#39;我是index方法&#39;)</code></pre><p>修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：<br>​<br>    class TestMiddlware1(MiddlewareMixin):</p><pre><code>    def process_request(self, request):        print(&#39;test1 process_request&#39;)    def process_response(self, request, response):        print(&#39;test1 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test1 process_view&#39;)    def process_exception(self, request, exception):        print(&#39;test1 process_except&#39;)class TestMiddlware2(MiddlewareMixin):    def process_request(self, request):        print(&#39;test2 process_request&#39;)    def process_response(self, request, response):        print(&#39;test2 process_response&#39;)        return response    def process_view(self, request, view_func, view_args, view_kwargs):        print(&#39;test2 process_view&#39;)    def process_exception(self, request, exception):        print(&#39;test2 process_except&#39;)</code></pre><p>访问index路由地址，在控制台中可以打印如下的内容: </p><pre><code>test1 process_requesttest2 process_requesttest1 process_viewtest2 process_viewindex viewstest2 process_excepttest1 process_excepttest2 process_responsetest1 process_response</code></pre><p>从结果中可以得出以下结论:</p><pre><code>1）    process_request最先执行。并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行。2）    process_view在视图函数之前执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行。3）    视图函数在process_view方法执行后执行，在process_exception方法之前执行。4）    process_exception方法在process_response方法之前执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。5）    process_response方法是最后执行的，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web后端Django-前戏3关联表操作</title>
      <link href="/2019/01/04/web-hou-duan-django-qian-xi-3-guan-lian-biao-cao-zuo/"/>
      <url>/2019/01/04/web-hou-duan-django-qian-xi-3-guan-lian-biao-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p><strong>操作背景：是在前戏2中已经创建有学生表，同时也完成了单表的查询，此篇的目的是创建关联表以及相关的关联操作</strong></p><h2 id="1-创建拓展表（一对一）"><a href="#1-创建拓展表（一对一）" class="headerlink" title="1.创建拓展表（一对一）"></a>1.创建拓展表（一对一）</h2><ul><li>工程文件夹下app下modles.py<pre><code>class StudentInfo(models.Model):  s_no = models.CharField(max_length=10,null=False)  phone = models.CharField(max_length=11,null=True)  name = models.CharField(max_length=10,null=True)  #定义一对一的关联关系  # on_delete：  # models.CASCADE：删除主表，从表也会被删除  # models.PROTECT:都会被保护，但是从表可以删除  # models.SET_NULL:主表被删除，从表的外键设置为空  stu = models.OneToOneField(Student,                            on_delete=models.SET_NULL,                            related_name=&#39;info&#39;,                            null=True)</code></pre></li><li>对表做修改以及添加新表后都需要迁移文件，在终端中执行代码进行迁移命令<ul><li>python manage.py makemigrations</li><li>python manage.py migrate<h3 id="先观察数据库"><a href="#先观察数据库" class="headerlink" title="先观察数据库"></a>先观察数据库</h3>查看当前数据库中有哪些表格查看图片如下：<br>(/images/stu_orige.png)<h3 id="1-添加学生拓展表信息"><a href="#1-添加学生拓展表信息" class="headerlink" title="1.添加学生拓展表信息"></a>1.添加学生拓展表信息</h3><h4 id="进入urls-py添加路由"><a href="#进入urls-py添加路由" class="headerlink" title="进入urls.py添加路由"></a>进入urls.py添加路由</h4><pre><code>path(&#39;add_stu_info/&#39;,views.add_stu_info),</code></pre><h4 id="进入views-py创建拓展信息表"><a href="#进入views-py创建拓展信息表" class="headerlink" title="进入views.py创建拓展信息表"></a>进入views.py创建拓展信息表</h4></li></ul></li><li>方法一：<pre><code>  stu_info = StudentInfo()  stu_info.s_no = &#39;123456&#39;  stu_info.phone = &#39;18328099786&#39;  stu_info.name = &#39;小花22&#39;    #此处模型中定义为紧急联系人  stu_info.stu = Student.objects.get(id=4) # 获取学生对象进行关联  stu_info.save()  return HttpResponse(&#39;创建拓展信息成功&#39;)</code></pre></li><li>方法二：<pre><code>  stu_info = StudentInfo()  stu_info.s_no = &#39;123456&#39;  stu_info.phone = &#39;18328099786&#39;  stu_info.name = &#39;小花22&#39;  stu_info.stu_id = 5  stu_info.save()  return HttpResponse(&#39;创建拓展信息成功&#39;)</code></pre><h4 id="（1）通过学生对象查询拓展表信息"><a href="#（1）通过学生对象查询拓展表信息" class="headerlink" title="（1）通过学生对象查询拓展表信息"></a>（1）通过学生对象查询拓展表信息</h4><h5 id="此处用于区分关联时id的写法"><a href="#此处用于区分关联时id的写法" class="headerlink" title="此处用于区分关联时id的写法"></a>此处用于区分关联时id的写法</h5></li><li>（1）创建路由<pre><code>path(&#39;sel_phone_by_stu/&#39;,views.sel_phone_by_stu),</code></pre></li><li>（2）在views中写代码查询,方法一<pre><code>def sel_phone_by_stu(request):  # 1.查询学生对象  stu = Student.objects.filter(s_name=&#39;小花&#39;).first()  stu_info = StudentInfo.objects.filter(stu_id=stu.id).first() #在获取学生对象之后关联到StudentInfo；  phone = stu_info.phone  print(phone)  return  HttpResponse(&#39;查询成功&#39;)</code></pre></li><li>（2）在views中写代码查询,方法二<pre><code>def sel_phone_by_stu(request):  stu = Student.objects.filter(s_name=&#39;小花&#39;).first()  stu_info = StudentInfo.objects.filter(stu=stu).first()  phone = stu_info.phone  print(phone)  return  HttpResponse(&#39;查询成功&#39;)</code></pre><h4 id="（2）通过学生对象查询拓展表信息"><a href="#（2）通过学生对象查询拓展表信息" class="headerlink" title="（2）通过学生对象查询拓展表信息"></a>（2）通过学生对象查询拓展表信息</h4><h5 id="此处用于区分关联时有无关联名称是的写法"><a href="#此处用于区分关联时有无关联名称是的写法" class="headerlink" title="此处用于区分关联时有无关联名称是的写法"></a>此处用于区分关联时有无关联名称是的写法</h5></li><li>（1）创建路由,在urls.py中<pre><code>path(&#39;sel_phone_by_stu2/&#39;,views.sel_phone_by_stu2),</code></pre></li><li><strong>没有</strong>关联名称时即》》在模型中拓展表的stu没有字段related_name=’info’,<pre><code>  stu = models.OneToOneField(Student,on_delete=models.SET_NULL,null=True)</code></pre>此时的查询代码为：<pre><code>def sel_phone_by_stu2(request):  # 1.查询学生对象  stu = Student.objects.filter(s_name=&#39;小花&#39;).first()  # 2.反向查询，关联模型对象，关联另外一个模型名称的小写  stu_inifo = stu.studentinfo  phone = stu_inifo.studentinfo  print(phone)  return HttpResponse(&#39;查询成功,没有关联名称&#39;)</code></pre></li><li><strong>有</strong>关联名称时即》》在模型中拓展表的stu字段有related_name=’info’,<pre><code>def sel_phone_by_stu2(request):  # 1.查询学生对象  stu = Student.objects.filter(s_name=&#39;小花&#39;).first()  # 2.反向查询，直接学生对象到关联名称的名  stu_inifo = stu.info  phone = stu_inifo.phone  print(phone)  return HttpResponse(&#39;查询成功,有关联名称的查询&#39;)</code></pre><h4 id="（3）通过拓展表查询学生信息"><a href="#（3）通过拓展表查询学生信息" class="headerlink" title="（3）通过拓展表查询学生信息"></a>（3）通过拓展表查询学生信息</h4></li><li>（1）创建路由，urls中<pre><code>path(&#39;sel_stu_by_info/&#39;,views.sel_stu_by_info),</code></pre></li><li>（2）先在拓展表中取出对象，关联到stu字段中，因为彼此为一对一对应的<pre><code>def sel_stu_by_info(request):  stu_info = StudentInfo.objects.filter(s_no=&#39;123456&#39;).first()  stu = stu_info.stu  print(stu.s_name)  return HttpResponse(&#39;查询成功，拓展表查询学生对象。&#39;)</code></pre><h3 id="2-删除学生信息"><a href="#2-删除学生信息" class="headerlink" title="2 删除学生信息"></a>2 删除学生信息</h3></li><li>（1）创建路由<pre><code>path(&#39;on_delete_stu/&#39;,views.on_delete_stu),</code></pre><strong>注意：</strong>在定义一对一的关联关系时，需要顶底on_delete的值</li><li>models.CASCADE：删除主表，从表也会被删除<ul><li>models.PROTECT:都会被保护，但是从表可以删除</li><li>models.SET_NULL:主表被删除，从表的外键设置为空<pre><code>def on_delete_stu(request):# 删除小花的学生信息#删除小花信息，从表是否删除Student.objects.filter(s_name=&#39;小花2&#39;).delete()return HttpResponse(&#39;删除成功&#39;)</code></pre><h2 id="2班级表（一对多）"><a href="#2班级表（一对多）" class="headerlink" title="2班级表（一对多）"></a>2班级表（一对多）</h2><h4 id="（1）创建班级表"><a href="#（1）创建班级表" class="headerlink" title="（1）创建班级表"></a>（1）创建班级表</h4></li></ul></li><li>1在models.py文件中写入代码<pre><code>class Grade(models.Model):  g_name = models.CharField(max_length=10,unique=True)  class Meta:  #此处的是定义表名      db_table = &#39;grade&#39;</code></pre></li><li>（1）在前戏2中所创建的student类中<ul><li>一对多的外键定义<pre><code>g = models.ForeignKey(Grade,null=True,on_delete=models.CASCADE,                      related_name=&#39;stu&#39;)</code></pre><strong>注意添加外键后要做迁移命令</strong><h4 id="（2）添加班级信息"><a href="#（2）添加班级信息" class="headerlink" title="（2）添加班级信息"></a>（2）添加班级信息</h4></li></ul></li><li><strong>创建路由</strong>一对多操作,添加班级信息<pre><code>path(&#39;add_grade/&#39;,views.add_grade),</code></pre></li><li>1.添加方法一<pre><code>  for i in range(1,5):  grade = Grade()      grade.g_name = &#39;java180&#39;+str(i)      grade.save()</code></pre></li><li>2.添加方法二<pre><code>def add_grade(requset):for i in range(1,5):  Grade.objects.create(g_name=&#39;python180&#39;+str(i))return HttpResponse(&#39;添加成功&#39;)</code></pre><h4 id="（3）给学生分配班级信息"><a href="#（3）给学生分配班级信息" class="headerlink" title="（3）给学生分配班级信息"></a>（3）给学生分配班级信息</h4></li><li>1.创建路由<pre><code>path(&#39;stu_grade/&#39;,views.stu_grade),</code></pre></li><li>2.分配班级（两种方法）查询id=6的对象(对id为6的学生分配班级)<pre><code>def stu_grade(requset):  stu = Student.objects.get(pk=6)  #  # stu.g = Grade.objects.get(pk=1)  stu.g_id = 4  stu.save()  return HttpResponse(&#39;分配班级成功&#39;)</code></pre><h2 id="3-一对多的表单查询"><a href="#3-一对多的表单查询" class="headerlink" title="3.一对多的表单查询"></a>3.一对多的表单查询</h2><h4 id="（1）通过学生查询班级"><a href="#（1）通过学生查询班级" class="headerlink" title="（1）通过学生查询班级"></a>（1）通过学生查询班级</h4></li><li>创建路由<pre><code>path(&#39;sel_grade_by_stu/&#39;,views.sel_grade_by_stu),</code></pre></li><li>查询方法<pre><code>def sel_grade_by_stu(request):  # 1.查询姓名叫小明的对象  stu =  Student.objects.filter(s_name=&#39;小明&#39;).first()  grade = stu.g  #此处添加了一对多的外键，因此可以得到班级的对象  print(grade.g_name)  return  HttpResponse(&#39;查询成功&#39;)</code></pre><h4 id="（2）通过班级查询学生"><a href="#（2）通过班级查询学生" class="headerlink" title="（2）通过班级查询学生"></a>（2）通过班级查询学生</h4></li><li>创建路由<pre><code>path(&#39;sel_stu_by_grade/&#39;,views.sel_stu_by_grade),</code></pre></li><li>查询方法一（没有创建关联名称的情况）<pre><code>def sel_stu_by_grade(request):  grade = Grade.objects.filter(g_name=&#39;python1801&#39;).first()  stus = grade.student_set.all()  #  for stu in stus:  print(stu.s_name,stu.s_age,stu.s_gender)  return HttpResponse(&#39;查询学生成功，无关联名称&#39;)</code></pre></li><li>查询方法一（有创建关联名称的情况）;即学生表中 g = models.ForeignKey(Grade,null=True,on_delete=models.CASCADE,related_name=’stu’)中有<pre><code>def sel_stu_by_grade(request):  # 1.查询班级python1801  grade = Grade.objects.filter(g_name=&#39;python1801&#39;).first()  stus = grade.stu.all()  for stu in stus:      print(stu.s_name,stu.s_age,stu.s_gender)  return HttpResponse(&#39;查询学生成功,有关联名称&#39;)</code></pre><h2 id="4学生选课表（多对多）"><a href="#4学生选课表（多对多）" class="headerlink" title="4学生选课表（多对多）"></a>4学生选课表（多对多）</h2><h3 id="（1）创建选课表"><a href="#（1）创建选课表" class="headerlink" title="（1）创建选课表"></a>（1）创建选课表</h3></li><li><p>在models.py中写入代码创建选课表,同时在终端中做迁移。</p><ul><li>将会在数据库中多处一个course的 表</li><li><p>同时会多出course_stu的表如下图<br>(/images/manytomany.png)</p><pre><code>class Course(models.Model):c_name = models.CharField(max_length=10,unique=True)# ManyToManyField字段定义在任何一个模型都可以stu = models.ManyToManyField(Student,null=True,related_name=&#39;cou&#39;)class Meta:    db_table = &#39;course&#39;</code></pre><h3 id="（2）添加课程信息"><a href="#（2）添加课程信息" class="headerlink" title="（2）添加课程信息"></a>（2）添加课程信息</h3></li></ul></li><li>创建路由<pre><code>path(&#39;add_course/&#39;,views.add_course),</code></pre></li><li>写入添加课程的方法一：<pre><code>def add_course(request):  c_names = [&#39;大学英语&#39;,&#39;商务英语&#39;,&#39;线代&#39;,&#39;高数&#39;]  for i in c_names:      course = Course()      course.c_name =i      course.save()  return HttpResponse(&#39;添加课程成功&#39;)</code></pre></li><li>写入添加课程的方法二：<pre><code>def add_course(request):  c_names = [&#39;大学英语&#39;,&#39;商务英语&#39;,&#39;线代&#39;,&#39;高数&#39;]  for i in c_names:      Course.objects.create(c_name=i)  return HttpResponse</code></pre><h4 id="（3）给中间表添加信息（学生添加课程）"><a href="#（3）给中间表添加信息（学生添加课程）" class="headerlink" title="（3）给中间表添加信息（学生添加课程）"></a>（3）给中间表添加信息（学生添加课程）</h4></li><li>创建路由<pre><code>path(&#39;add_s_c/&#39;,views.add_s_c),</code></pre>两种方法的区别就在关联关系这儿</li><li>添加方法一：（无关联名称）<pre><code>def add_s_c(request):  #1 查询课程对象  cou = Course.objects.filter(c_name=&#39;商务英语&#39;).first()  #2.查询学生对象  stu = Student.objects.filter(s_name=&#39;lorry&#39;).first()  # 3.加入关联关系  stu.course_set.add(cou)  return HttpResponse(&#39;添加中间信息表成功&#39;)</code></pre></li><li>添加方法二：（有关联名称cou）<pre><code>def add_s_c(request):  #1 查询课程对象  cou = Course.objects.filter(c_name=&#39;商务英语&#39;).first()  #2.查询学生对象  stu = Student.objects.filter(s_name=&#39;lorry&#39;).first()  # 3.加入关联关系  stu.cou.add(cou)     return HttpResponse(&#39;添加中间信息表成功&#39;)</code></pre><h4 id="4-给中间表添加信息（课程添加学生）"><a href="#4-给中间表添加信息（课程添加学生）" class="headerlink" title="4.给中间表添加信息（课程添加学生）"></a>4.给中间表添加信息（课程添加学生）</h4><pre><code>def add_s_c(request):  #将大学英语分配给小明  #1 查询课程对象  cou = Course.objects.filter(c_name=&#39;商务英语&#39;).first()  #2.查询学生对象  stu = Student.objects.filter(s_name=&#39;lorry&#39;).first()  cou.stu.add(stu)  #前面的stu是模型中定义的stu。  return HttpResponse(&#39;添加中间信息表成功&#39;)</code></pre><h4 id="5-删除中间表信息"><a href="#5-删除中间表信息" class="headerlink" title="5.删除中间表信息"></a>5.删除中间表信息</h4></li><li>创建路由<pre><code>path(&#39;del_s_c/&#39;,views.del_s_c)</code></pre></li><li>写入方法<pre><code>def del_s_c(requset):  cou = Course.objects.filter(c_name=&#39;商务英语&#39;).first()  stu = Course.objects.filter(s_name=&#39;lorry&#39;).first()  stu.cou.remove(cou)  return HttpResponse(&#39;删除信息成功&#39;)</code></pre><h2 id="5-模板（HTML的操作）"><a href="#5-模板（HTML的操作）" class="headerlink" title="5.模板（HTML的操作）"></a>5.模板（HTML的操作）</h2></li><li>创建路由<pre><code>path(&#39;index/&#39;,views.index)</code></pre>后续操作：</li><li>a:在工程文件中创建templates的文件夹<ul><li>b:在文件夹中创建index.html文件</li><li>c:进入文件操作解析内容<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;欢迎lorry&lt;/p&gt;{% for stu in a%}    <p>        姓名：{{stu.s_name}}        年龄：{{stu.s_age}}        班级：{{ stu.g.g_name }}        选课：            {% for c in stu.cou.all %}                {{ c.c_name }}            {% endfor %}&lt;/p&gt;{% endfor %}&lt;/body&gt;&lt;/html&gt;</p></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web后端Django-前戏之数据库增删改查</title>
      <link href="/2019/01/03/web-hou-duan-django-qian-xi-2-shu-ju-ku-zeng-shan-gai-cha/"/>
      <url>/2019/01/03/web-hou-duan-django-qian-xi-2-shu-ju-ku-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>ORM(objects relationship mapping): 对象关系映射；<br>objects: 管理器，默认模型的属性；</p><h3 id="1-数据增加中间表（即自己需要管理的表）"><a href="#1-数据增加中间表（即自己需要管理的表）" class="headerlink" title="1.数据增加中间表（即自己需要管理的表）"></a>1.数据增加中间表（即自己需要管理的表）</h3><h5 id="举例操作：创建一张学生表，包含名字，性别，年龄，创立日期以及更新日期；"><a href="#举例操作：创建一张学生表，包含名字，性别，年龄，创立日期以及更新日期；" class="headerlink" title="举例操作：创建一张学生表，包含名字，性别，年龄，创立日期以及更新日期；"></a>举例操作：创建一张学生表，包含名字，性别，年龄，创立日期以及更新日期；</h5><ul><li>a：在django-admin startproject app . 或者 python manage.py startapp app之后即可看见工程中有app文件，其中有一个model.py文件，进入即可。</li><li>b：创建类以及创建表名字，需要导入model模块<pre><code>from django.db import models# Create your models here.class Student(models.Model):  s_name = models.CharField(max_length=10,unique=True)  s_age = models.IntegerField(default=20)  s_gender = models.BooleanField(default=0)  create_time = models.DateTimeField(auto_now_add=True)  # auto_now_add   创建时，默认字段赋值为最新的事件  # create_time = models.DateField  updata_time = models.DateTimeField(auto_now=True)  # 修改数据是，自动赋值为更新字段时 的时间。  math = models.DecimalField(max_digits=3,decimal_places=1,null=True)  wuli = models.DecimalField(max_digits=3,decimal_places=1,null=True)  class Meta:      db_table = &#39;student&#39;</code></pre></li><li>c：在pycharm终端中执行两条迁移命令,即可在数据库中创建表；<ul><li>生成迁移文件：python manage.py makemigrations；</li><li>执行迁移文件“：python manage.py migrate；<h3 id="2-数据库的增操作"><a href="#2-数据库的增操作" class="headerlink" title="2.数据库的增操作"></a>2.数据库的增操作</h3></li></ul></li><li>a：进入url.py文件，在urlpatterns中增加路径同时导入相应模块。<pre><code>模块导入：from django.contrib import adminfrom django.urls import pathfrom app import views</code></pre>增加添加学生模块：<pre><code># https://120.0.0.1:8080/add_stu/  访问路由即可插入学生信息# 增加学生信息path(&#39;add_stu/&#39;,views.add_stu)</code></pre></li><li><p>b：进入views.py文件中导入模块以及写入相应函数方法<br>模块导入：</p><pre><code>from django.shortcuts import renderfrom django.http import HttpResponse# Create your viewshere.from app.models import Student</code></pre><p>写入添加学生方法：</p><pre><code>def add_stu(request):  #实现插入学生信息，第一种方式；  Student.objects.create(s_name=&#39;小明&#39;)  #实现插入学生信息，第二种方式，使用对象的方式进行添加学生信息。def add_stu(request):  stu = Student()  stu.s_name = &#39;lorry&#39;  stu.s_age = 26  stu.s_gender = 1  stu.save()  return  HttpResponse(&#39;创建学生成功&#39;)</code></pre><h3 id="3-数据库的删操作"><a href="#3-数据库的删操作" class="headerlink" title="3.数据库的删操作"></a>3.数据库的删操作</h3></li><li>a：进入url.py文件，在urlpatterns中增加路由路径。<pre><code>  #删除学生信息  path(&#39;del_stu/&#39;,views.del_stu),</code></pre></li><li>b：进入views.py文件中导入模块以及写入相应函数方法<br>模块导入：<pre><code>def del_stu(requset):  #实现删除  #1.获取删除的对象，filter(条件)  #2.实现删除方法，delete()  Student.objects.filter(id=3).delete()  return HttpResponse(&#39;删除学生成功&#39;)</code></pre><h3 id="4-数据库的更新操作"><a href="#4-数据库的更新操作" class="headerlink" title="4.数据库的更新操作"></a>4.数据库的更新操作</h3></li><li>a：进入url.py文件，在urlpatterns中增加路径。<pre><code>  更新学生  path(&#39;up_stu/&#39;,views.up_stu),</code></pre></li><li>b：进入views.py文件中导入模块以及写入相应函数方法<br>模块导入：<ul><li>更新的第一种方法：</li><li>说明：</li><li>1.获取更新的数据，filter(条件)</li><li>2.实现更新方法，update()<pre><code>def up_stu(requset):#Student.objects.filter(id=2).update(s_name=&#39;lorry&#39;)</code></pre></li></ul></li><li>更新的第二种方式,即可更新时间字段<pre><code>def up_stu(requset):  #更新的第二种方式,即可更新时间字段  stu = Student.objects.filter(id=2).first()  stu.s_name = &#39;lorrybz&#39;  stu.save()  return HttpResponse(&#39;更新学生成功&#39;)</code></pre><h3 id="5-数据库的查询操作"><a href="#5-数据库的查询操作" class="headerlink" title="5.数据库的查询操作"></a>5.数据库的查询操作</h3></li><li>a：进入url.py文件，在urlpatterns中增加路径。<pre><code>  #查询学生  path(&#39;sel_stu/&#39;,views.sel_stu),</code></pre></li><li>b：进入views.py文件中导入模块以及写入相应函数方法<br>######查询学生<pre><code>#导入模块from django.db.models import Avg, Max, Min, Sum, Count, Q, Fdef sel_stu(requset):  # 查询学生信息  #  查询所有的学生信息  stus = Student.objects.all()  for stu in stus:      print(stu.s_name)      print(stu.s_gender)</code></pre></li><li>使用过滤器查询学生fillter和git<pre><code>  # 查询id=2的学生，fillter  # 若是条件不成立不会报错，返回值为空  stu = Student.objects.filter(id=2).first()  print(stu.s_gender)  # 1.取唯一的一个对象  # 2.get(条件必须成立)，若是条件不成立会报错  stu = Student.objects.get(id=2)  print(stu)</code></pre></li><li>过滤出满足条件和不满条件的fillter和exclude。<pre><code>  # 过滤出不满足条件的信息上面是满足条件，下面是不满足条件的  stus = Student.objects.filter(s_gender=1)  print(stus)  stus = Student.objects.exclude(s_gender=0)  print(stus)</code></pre></li><li>排序：默认是升序，在id或者筛选条件前加 ‘-’即可将序<pre><code>  #排序order_by  stus = Student.objects.order_by(&#39;-id&#39;)  print(stus)</code></pre></li><li>取出对象中的某个字段<pre><code> stus = Student.objects.all().values(&#39;s_name&#39;,&#39;s_age&#39;) print(stus) stus = Student.objects.all().values() print(stus)</code></pre></li><li>判断查询结果是否存在<pre><code>  a = Student.objects.filter(s_name=&#39;校长&#39;).exists()  print(a)</code></pre></li><li><p>对过滤的条件进行计数，有两种方法</p><pre><code>方法1：  stus = Student.objects.filter(s_gender=1)  print(len(stus))方法2：  count = Student.objects.filter(s_gender=1).count()  print(count)  stus = Student.objects.filter(s_name=&#39;lorrybz&#39;).first()  print(stus)</code></pre></li><li><p>第二大类模糊查询contains</p><pre><code>  ##contains  # 字段——运算符  stus = Student.objects.filter(s_name__contains=&#39;小&#39;)  print(stus)  #like &#39;小%&#39;   &#39;%明&#39;  # startwith  endwith  stus = Student.objects.filter(s_name__startswith=&#39;小&#39;)  print(stus)  stus = Student.objects.filter(s_name__endswith=&#39;z&#39;)  print(stus)  # sql where id in (12345679)  # 模糊判断  stus = Student.objects.filter(id__in=[1,2,3,4,5])  print(stus)  stus = Student.objects.filter(pk__in=[1,2,3,4,5])  print(stus)</code></pre></li><li>比较运算符<pre><code>  #gt &gt;;gte &gt;=;   lt &lt;; lte &lt;=;#并且操作  stus = Student.objects.filter(s_age__gte=18,s_age__lt=20)  print(stus)  stus = Student.objects.filter(s_age__gte=18).filter(s_age__lt=20)  print(stus)</code></pre></li><li>聚合函数 avg max min sum count<ul><li>语法: 模型名.objects.all().aggregate(Sum(字段))<pre><code># 聚合函数 avg max min sum countage_avg = Student.objects.all().aggregate(Avg(&#39;s_age&#39;))print(age_avg)sum_avg = Student.objects.all().aggregate(Sum(&#39;s_age&#39;))print(sum_avg)max_avg = Student.objects.all().aggregate(Max(&#39;s_age&#39;))print(max_avg)min_avg = Student.objects.all().aggregate(Min(&#39;s_age&#39;))print(min_avg)</code></pre></li></ul></li><li><p>与或非的计算</p><ul><li>要点（1）Q将条件包起来进行与或非函数的比较</li><li>要点（2）与1: Q(条件1), Q(条件2)</li><li>要点（3）与2: Q(条件1) &amp; Q(条件2) ；: Q(条件1)  and  Q(条件2) ；  </li><li>要点（4）或: Q(条件1) | Q(条件2)   ；Q(条件1)  or  Q(条件2) </li><li>要点（5）非: ~Q(条件1)</li><li>要点（6）用于比较两个字段,可使用+,-符号</li><li><p>模型名.objects.filter(wuli__gt=F(‘math’)-10)</p><pre><code>#查询年龄大于等于18  且 小于20stus = Student.objects.filter(s_age__gte=18, s_age__lt=20)print(stus)#  ，&amp; 和and 是且的操作   or 或者， 查询年龄大于等于18 或者  小于等20stus = Student.objects.filter(Q(s_age__gte=18) | Q(s_age__lte=20))print(stus)stus = Student.objects.filter(~Q(s_age__gt=18))print(stus)#查询物理成绩大于数学成绩的学生stus = Student.objects.all()for stu in stus:    if stu.wuli &gt; stu.math:        print(stu.s_name)stus = Student.objects.filter(wuli__gt=F(&#39;math&#39;)+10).first()print(stus.s_name)</code></pre></li></ul></li><li>最后一句通用的：<pre><code>  return HttpResponse(&#39;查询所有学生信息&#39;)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>非关系型数据库</title>
      <link href="/2019/01/02/fei-guan-xi-xing-shu-ju-ku-2redis/"/>
      <url>/2019/01/02/fei-guan-xi-xing-shu-ju-ku-2redis/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分redis的安装以及挂载"><a href="#第一部分redis的安装以及挂载" class="headerlink" title="第一部分redis的安装以及挂载"></a>第一部分redis的安装以及挂载</h2><h3 id="1-进入Linux系统或者在服务器中下载文件"><a href="#1-进入Linux系统或者在服务器中下载文件" class="headerlink" title="1.进入Linux系统或者在服务器中下载文件"></a>1.进入Linux系统或者在服务器中下载文件</h3><p>wget <a href="http://download.redis.io/releases/redis-5.0.3.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.3.tar.gz</a></p><h3 id="2-解压文件"><a href="#2-解压文件" class="headerlink" title="2.解压文件"></a>2.解压文件</h3><p>gunzip redis-5.0.3.tar.gz</p><h3 id="3-解归档文件，以及切换至redis-5-0-3-文件夹中"><a href="#3-解归档文件，以及切换至redis-5-0-3-文件夹中" class="headerlink" title="3.解归档文件，以及切换至redis-5.0.3/文件夹中"></a>3.解归档文件，以及切换至redis-5.0.3/文件夹中</h3><p>tar -xvf redis-5.0.3.tar  ； cd redis-5.0.3/<br><strong>补充：1.gcc -v  or  gcc –version;查看当前gcc版本</strong><br>     <strong>2.ps -ef | grep redis</strong></p><h3 id="4-执行安装redis-执行第一句安装，接着第二句"><a href="#4-执行安装redis-执行第一句安装，接着第二句" class="headerlink" title="4.执行安装redis,执行第一句安装，接着第二句"></a>4.执行安装redis,执行第一句安装，接着第二句</h3><p>make &amp;&amp; make install  </p><h3 id="5-启动服务"><a href="#5-启动服务" class="headerlink" title="5.启动服务"></a>5.启动服务</h3><ul><li>（1）redis-server;  直接在前台运行且裸奔；</li><li>（2）redis-server &amp;; 在后台运行且裸奔；</li><li>（3）redis-server &gt; redis.log 2&gt; redis-error.log &amp;;在后台运行且裸奔，实质是将日志重定向到redis.log，且若是错误的结束将错误日志重定向到redis-error.log中；</li><li>（7）redis-server –requirepass 123456 &gt; redis.log 2&gt; redis-error.log &amp; 在后台运行，重定向日志，设置密码且不裸奔，但若是错误结束将u自动保存；</li><li>（8）redis-server –requirepass lorry1234 –appendonly yes &gt; redis.log 2&gt; redis-error.log &amp;  在后台运行，重定向日志，不裸奔，自动保存；<h3 id="6-进入客户端"><a href="#6-进入客户端" class="headerlink" title="6.进入客户端,"></a>6.进入客户端,</h3>redis-cli;链接自己<br>redis-cli -h 120.77.45.55 -p 6379 -a 1qaz2wsx<h3 id="7-当出现遗传ip时即可输入密码进入"><a href="#7-当出现遗传ip时即可输入密码进入" class="headerlink" title="7.当出现遗传ip时即可输入密码进入"></a>7.当出现遗传ip时即可输入密码进入</h3>auth lorry1234;</li></ul><h2 id="第二部分redis简介"><a href="#第二部分redis简介" class="headerlink" title="第二部分redis简介"></a>第二部分redis简介</h2><p>kv存储系统 - REmote DIctionary Server<br>提供高速缓存服务、缓存热点数据<br>缓解了数据的压力，访问数据不用直接访问数据库</p><h2 id="第三部分redis一部分基操"><a href="#第三部分redis一部分基操" class="headerlink" title="第三部分redis一部分基操"></a>第三部分redis一部分基操</h2><ul><li>心跳事件：ping</li><li>查看历史：history -c</li><li>设置键值对：set username lorry</li><li>取值：get username </li><li>设置键值对生存时间：set email <a href="mailto:lorry@qq.com" target="_blank" rel="noopener">lorry@qq.com</a> ex 20</li><li>设置未设置生存时间的键值对的生存时间：expire key </li><li>查看键值生存时间:ttl email</li><li>删除键值对:del key</li><li>查看所有的键值对:keys *</li><li>key y<em>  ,key u</em> :等我查查</li><li>清空数据库：flushdb</li><li>清楚所有数据库中的所有键值对：flushall</li><li>判断键是否存在：exists key；返回值是布尔值；</li><li>换底层数据库，默认中有16个数据库：select 1   ；编号为（0-15）</li><li>关闭服务器：shutdown</li><li>退出：quit</li><li>保存：save ，后台保存：bgsave </li><li>查看当前数据库有多少键值对：dbsize  </li><li>执行时加1 ：incr   </li><li>执行时加100：incrby 100；100可以自定义</li><li>减1：decr</li><li>减200：decrby 200；<h3 id="redis提供了两种是九华数据的方案："><a href="#redis提供了两种是九华数据的方案：" class="headerlink" title="redis提供了两种是九华数据的方案："></a>redis提供了两种是九华数据的方案：</h3>1.RDB - 默认开启<br>2.AOF - 默认关闭  –appendonly yes   意外情况只是丢失1秒钟的数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web后端Django-前戏</title>
      <link href="/2019/01/02/web-hou-duan-django-qian-xi-1-huan-jing-da-jian/"/>
      <url>/2019/01/02/web-hou-duan-django-qian-xi-1-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-配置虚拟环境"><a href="#1-配置虚拟环境" class="headerlink" title="1.配置虚拟环境"></a>1.配置虚拟环境</h3><h4 id="（1）pycharm中直接配置"><a href="#（1）pycharm中直接配置" class="headerlink" title="（1）pycharm中直接配置"></a>（1）pycharm中直接配置</h4><ul><li>A.在pycharm中创建工程时，就开始创建虚拟环境。</li><li>B.安装django pymysql django-redis    <ul><li>pycharm终端命令：pip install django pymysql django-redis</li></ul></li><li>C.将依赖库重定向到文件中，方便别人copy时直接通过txt配置虚拟环境<ul><li>终端命令：pip freeze &gt; requirements.txt</li><li>例如：将文件中的依赖库一句话安装到虚拟环境中</li><li>pip install -r requirements.txt </li></ul></li><li>D.开始Django项目,注意最后有一个空格 + .。<ul><li>终端命令：django-admin startproject hellodjango .</li></ul></li><li>E.执行项目，manage.py是自动创好的。<ul><li>终端命令：python manage.py runserver</li><li>执行后可以通过<a href="http://localhost:8000或者http://127.0.0.1:8000进行查看" target="_blank" rel="noopener">http://localhost:8000或者http://127.0.0.1:8000进行查看</a></li></ul></li><li>F.（1）第一次迁移<ul><li>数据库迁移（是在数据库配置好之后执行的命令），建立十张表</li><li>终端命令：python manage.py migrate<br>-（2）以后的迁移：当建立中间表需要在数据库持久化则需要再次迁移</li><li>生成迁移文件：python manage.py makemigrations</li><li>执行迁移文件“：python manage.py migrate</li></ul></li><li>G.Django创建管理员账号<ul><li>python manage.py createsuperuser</li></ul></li></ul><h4 id="（2）windows中cmd、redhat、centos等中虚拟环境的配置"><a href="#（2）windows中cmd、redhat、centos等中虚拟环境的配置" class="headerlink" title="（2）windows中cmd、redhat、centos等中虚拟环境的配置"></a>（2）windows中cmd、redhat、centos等中虚拟环境的配置</h4><ul><li>A：准备工作1<ul><li>在自己记得住的文件夹下创建两个文件夹用于区分虚拟环境和工作环境分别为env(虚拟环境)和workspace工作环境</li></ul></li><li>AA：准备工作2<ul><li>给全局配置安装虚拟环境</li><li>终端命令：pip install virtualenv</li></ul></li><li>B：配置项目的单独的虚拟环境<ul><li>在cmd或者其余的系统中将路径切换到enc目录下。建议使用git或者xsheel，不使用cmd**终端。</li><li>终端指令：virtualenv –no-site-packages -p C:\Users\ThinkPad\AppData\Local\Programs\Python\Python37\python.exe DJenv1808</li><li>代码解释：</li><li>–no-site-packages：创建纯净环境，无杂质。</li><li>-p：python版本的绝对路径，是针对系统上有多个python版本。若只有一个直接不写。</li><li>DJenv1808  ：存放工程的虚拟环境的文件夹。</li></ul></li><li>C：激活、杀死环境<ul><li>进入enc/Scripts文件夹</li><li>cmd中：进入文件夹后直接输入：activate。然后回车即激活环境。</li><li>mac以及无界面系统中进入文件夹后输入：source activate。然后回车即激活环境。</li><li><strong>状态激活标识：在终端中显示将会出现    （(DJenv1808)）</strong></li><li>退出环境：所有的退出环境操作均一样。终端操作命令：deactivate   </li></ul></li><li>D：在激活状态下<ul><li>a（pycharm中可在中断中执行上述的操作进行。</li><li>b在cmd以及其他中：<h6 id="（1）将目录切换至之前创建的workspace下，创建django文件夹"><a href="#（1）将目录切换至之前创建的workspace下，创建django文件夹" class="headerlink" title="（1）将目录切换至之前创建的workspace下，创建django文件夹"></a>（1）将目录切换至之前创建的workspace下，创建django文件夹</h6><h6 id="（2）执行代码：django-admin-startproject-test"><a href="#（2）执行代码：django-admin-startproject-test" class="headerlink" title="（2）执行代码：django-admin startproject test"></a>（2）执行代码：django-admin startproject test</h6></li></ul></li><li>E：用pycharm打开为项目名称的这个工程<ul><li>在pycharm终端中启动命令：python manange.py runserver   8080 or 0.0.0.0:8080即可看到页面。</li></ul></li><li>G：创建app子工程<ul><li>在pycharm的终端中执行代码：python manage.py startapp app</li></ul></li><li>H.（1）第一次迁移<ul><li>数据库迁移（是在数据库配置好之后执行的命令），建立十张表</li><li>终端命令：python manage.py migrate<br>-（2）以后的迁移：当建立中间表需要在数据库持久化则需要再次迁移</li><li>生成迁移文件：python manage.py makemigrations</li><li>执行迁移文件“：python manage.py migrate</li></ul></li><li>I :对后台数据创建超级管理员<ul><li>.终端执行代码：python manage.py createsuperuser<h3 id="2-MVT和MVC模式："><a href="#2-MVT和MVC模式：" class="headerlink" title="2.MVT和MVC模式："></a>2.MVT和MVC模式：</h3><strong>MVT模式是由MVC模式演变出来的，MVC模式是所有框架遵循的模式</strong><br>MVT：M：models.py——模型层<br> V：views.py————视图层<br> C：templates————模板，定义页面HTML的地方<br>MVC：<br>M:模型层<br>V：模板：HTML页面<br>C：controller，控制器，写业务逻辑的地方<h3 id="3-pip相关用法"><a href="#3-pip相关用法" class="headerlink" title="3.pip相关用法"></a>3.pip相关用法</h3></li></ul></li><li>查看虚拟环境下安装的所有的包　：pip list<ul><li>查看虚拟环境重通过pip安装的包 ：pip freeze    </li><li>查看是否冲突：pip check<h4 id="4-数据库配置"><a href="#4-数据库配置" class="headerlink" title="4.数据库配置"></a>4.数据库配置</h4></li></ul></li><li>当完成相关配置后即可配置数据库：找到test下setting.py.大概80行的位置。修改database为<pre><code>DATABASES = {  &#39;default&#39;: {      &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,      &#39;NAME&#39;: &#39;dj8&#39;,      &#39;USER&#39;:&#39;root&#39;,      &#39;PASSWORD&#39;:&#39;*****&#39;, #数据库密码      &#39;HOST&#39;:&#39;120.0.0.0&#39;, #服务器或者本地地址      &#39;PORT&#39;:3306,      &#39;TIME_ZONE&#39;:&#39;Asia/Chongqing&#39;  }}</code></pre><h4 id="5修改访问权限"><a href="#5修改访问权限" class="headerlink" title="5修改访问权限"></a>5修改访问权限</h4><pre><code>ALLOWED_HOSTS = [&#39;*&#39;]   #允许访问的主机ip地址</code></pre><h4 id="6-语言时区修改"><a href="#6-语言时区修改" class="headerlink" title="6.语言时区修改"></a>6.语言时区修改</h4><pre><code>LANGUAGE_CODE = &#39;zh-hans&#39;TIME_ZONE = &#39;Asia/Chongqing&#39;</code></pre><h4 id="7-数据库模块配置"><a href="#7-数据库模块配置" class="headerlink" title="7.数据库模块配置"></a>7.数据库模块配置</h4></li><li>a.在pycharm终端中执行代码：pip install pymysql <ul><li>此操作时连接国外网站进行下载可以通过其他方法进行提升</li><li>方法（1）：pip install -i <a href="https://pypi.doubanio.com/sample" target="_blank" rel="noopener">https://pypi.doubanio.com/sample</a> pymysql提升下载速度</li><li>方法（2）：修改系统配置文件</li><li>在C盘user或者用户下找到当前的管家（我的是thinkpad）新建一个文件夹pip,再新建一个后缀为ini文件名为pip的文件。</li><li>编辑文件为下内容即可<pre><code>[global]index-url=https://pypi.doubanio.com/simple</code></pre></li></ul></li><li>b.在ini.py文件中写下一下代码：<pre><code>import pymysqlpymysql.install_as_MySQLdb()</code></pre>前戏配置完毕</li></ul>]]></content>
      
      
      <categories>
          
          <category> web后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库操作-建表</title>
      <link href="/2018/12/27/shu-ju-ku-cao-zuo-2-jian-biao-yi-ji-cha-xun-lian-xi/"/>
      <url>/2018/12/27/shu-ju-ku-cao-zuo-2-jian-biao-yi-ji-cha-xun-lian-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><p>– 如果存在renliziyuan的数据库就删除它（慎重），之后创建数据库并且进入数据库。</p><pre><code>drop database if exists renliziyuan;create database renliziyuan default charset utf8;use renliziyuan;</code></pre><p>例子：创建人力资源管理系统数据</p><h3 id="2-创建部门表"><a href="#2-创建部门表" class="headerlink" title="2.创建部门表"></a>2.创建部门表</h3><h4 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h4><pre><code>drop table if exists tb_emp;create table tb_dept(dno int comment &#39;部门编号&#39;,dname varchar(10) not null comment &#39;部门名称&#39;,dloc varchar(20) not null comment &#39;部门所在地&#39;,primary key (dno));</code></pre><h4 id="添加部门记录"><a href="#添加部门记录" class="headerlink" title="添加部门记录"></a>添加部门记录</h4><pre><code>insert into tb_dept values     (10, &#39;会计部&#39;, &#39;北京&#39;),    (20, &#39;研发部&#39;, &#39;成都&#39;),    (30, &#39;销售部&#39;, &#39;重庆&#39;),    (40, &#39;运维部&#39;, &#39;深圳&#39;);</code></pre><h4 id="3-创建员工表"><a href="#3-创建员工表" class="headerlink" title="3.创建员工表"></a>3.创建员工表</h4><pre><code>drop table if exists tb_dept;create table tb_emp(eno int comment &#39;员工编号&#39;,ename varchar(20) not null comment &#39;员工姓名&#39;,job varchar(20) not null comment &#39;员工职位&#39;,mgr int comment &#39;主管编号&#39;,sal int not null comment &#39;员工工资&#39;,comm int comment &#39;每月补贴&#39;,dno int comment &#39;所在部门编号&#39;,primary key (eno),foreign key (dno) references tb_dept (dno));</code></pre><h4 id="3-添加员工信息"><a href="#3-添加员工信息" class="headerlink" title="3.添加员工信息"></a>3.添加员工信息</h4><pre><code>insert into tb_emp values     (7800, &#39;张三丰&#39;, &#39;总裁&#39;, null, 9000, 1200, 20),    (2056, &#39;乔峰&#39;, &#39;分析师&#39;, 7800, 5000, 1500, 20),    (3088, &#39;李莫愁&#39;, &#39;设计师&#39;, 2056, 3500, 800, 20),    (3211, &#39;张无忌&#39;, &#39;程序员&#39;, 2056, 3200, null, 20),    (3233, &#39;丘处机&#39;, &#39;程序员&#39;, 2056, 3400, null, 20),    (3251, &#39;张翠山&#39;, &#39;程序员&#39;, 2056, 4000, null, 20),    (5566, &#39;宋远桥&#39;, &#39;会计师&#39;, 7800, 4000, 1000, 10),    (5234, &#39;郭靖&#39;, &#39;出纳&#39;, 5566, 2000, null, 10),    (3344, &#39;黄蓉&#39;, &#39;销售主管&#39;, 7800, 3000, 800, 30),    (1359, &#39;胡一刀&#39;, &#39;销售员&#39;, 3344, 1800, 200, 30),    (4466, &#39;苗人凤&#39;, &#39;销售员&#39;, 3344, 2500, null, 30),    (3244, &#39;欧阳锋&#39;, &#39;程序员&#39;, 3088, 3200, null, 20),    (3577, &#39;杨过&#39;, &#39;会计&#39;, 5566, 2200, null, 10),    (3588, &#39;朱九真&#39;, &#39;会计&#39;, 5566, 2500, null, 10);</code></pre><h3 id="练习操作"><a href="#练习操作" class="headerlink" title="练习操作"></a>练习操作</h3><ul><li>查询薪资最高的员工姓名和工资<pre><code>select ename,sal from tb_emp where sal=(select max(sal) from tb_emp)</code></pre></li><li>查询员工的姓名和年薪((月薪+补贴)*12)<pre><code>select ename,(sal+ifnull(comm,0)*12) as 年薪 from tb_emp order by 年薪 desc;</code></pre></li><li>查询有员工的部门的编号和人数<pre><code>select ename,count(dno) from tb_emp group by dno;</code></pre><ul><li>查询所有部门的名称和人数（当列有二义性的时候需要使用完全限定名）<pre><code>select dname,ifnunll(total,0) from tb_dept as t1 left join (select dno,count(dno) as total from tb_emp group by dno) as t2 on t1.dno=t2.dno order by total desc;</code></pre></li><li>查询薪资最高的员工(Boss除外)的姓名和工资</li><li>查询薪水超过平均薪水的员工的姓名和工资</li><li>查询薪水超过其所在部门平均薪水的员工的姓名、部门编号和工资</li><li>查询部门中薪水最高的人姓名、工资和所在部门名称</li><li>查询主管的姓名和职位(集合运算和去重性能很差，开发过程中尽量避免使用)可以使用exists和notexists来代替集合运算和去重</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库操作1-建表以及查询</title>
      <link href="/2018/12/26/shu-ju-ku-cao-zuo-jian-biao/"/>
      <url>/2018/12/26/shu-ju-ku-cao-zuo-jian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><p>– 如果存在srs的数据库就删除它（慎重），之后创建数据库并且进入数据库。</p><pre><code>drop database if exists srs;create database srs default charset utf8;use srs;</code></pre><h3 id="2-创建二维表"><a href="#2-创建二维表" class="headerlink" title="2.创建二维表"></a>2.创建二维表</h3><p>例子：创建学生管理表并且添加信息</p><h4 id="1-创建学员表"><a href="#1-创建学员表" class="headerlink" title="1.创建学员表"></a>1.创建学员表</h4><pre><code>create table tb_college(collid int not null auto_increment comment &#39;学院编号&#39;,collname varchar(50) not null comment &#39;学院名称&#39;,collmaster varchar(20) not null comment &#39;院长姓名&#39;,collweb varchar(511) default &#39;&#39; comment &#39;学院网站&#39;,primary key (collid));</code></pre><ul><li>添加唯一性约束到学院名称<pre><code>alter table tb_college add constraint uni_college_collname unique (collname);</code></pre><h4 id="2-创建学生表"><a href="#2-创建学生表" class="headerlink" title="2.创建学生表"></a>2.创建学生表</h4><pre><code>create table tb_student(stuid int not null comment &#39;学号&#39;,sname varchar(20) not null comment &#39;学生姓名&#39;,gender bit default 1 comment &#39;性别&#39;,birth date not null comment &#39;出生日期&#39;,addr varchar(255) default &#39;&#39; comment &#39;籍贯&#39;,collid int not null comment &#39;所属学院编号&#39;,primary key (stuid));</code></pre></li><li>检查约束，mysql不支持：<pre><code>alter table tb_student add constraint ck_student_birth check (birth between &#39;1990-1-1&#39; and &#39;1999-12-31&#39;);</code></pre></li><li>添加外键约束<pre><code>alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid);</code></pre><h4 id="3-创建教师表"><a href="#3-创建教师表" class="headerlink" title="3.创建教师表"></a>3.创建教师表</h4><pre><code>create table tb_teacher(teaid int not null comment &#39;教师工号&#39;,tname varchar(20) not null comment &#39;教师姓名&#39;,title varchar(10) default &#39;&#39; comment &#39;职称&#39;,collid int not null comment &#39;所属学院编号&#39;);</code></pre></li><li>添加外键约束<pre><code>alter table tb_teacher add constraint pk_teacher primary key (teaid);</code></pre></li><li>添加外键约束<pre><code>alter table tb_teacher add constraint fk_teacher_collid foreign key (collid) references tb_college (collid);</code></pre><h4 id="4-插入学院数据"><a href="#4-插入学院数据" class="headerlink" title="4.插入学院数据"></a>4.插入学院数据</h4></li><li>插入学院数据<br><code>`</code><br>insert into tb_college (collname, collmaster, collweb) values<br>(‘计算机学院’, ‘左冷禅’, ‘<a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> </li></ul><p>‘),<br>(‘外国语学院’, ‘岳不群’, ‘<a href="http://www.xyz.com" target="_blank" rel="noopener">http://www.xyz.com</a> </p><p>‘),<br>(‘经济管理学院’, ‘风清扬’, ‘<a href="http://www.foo.com" target="_blank" rel="noopener">http://www.foo.com</a> </p><p>‘);</p><pre><code>#### 5.插入学生数据</code></pre><p>insert into tb_student (stuid, sname, gender, birth, addr, collid) values<br>(1001, ‘杨逍’, 1, ‘1990-3-4’, ‘四川成都’, 1),<br>(1002, ‘任我行’, 1, ‘1992-2-2’, ‘湖南长沙’, 1),<br>(1033, ‘王语嫣’, 0, ‘1989-12-3’, ‘四川成都’, 1),<br>(1572, ‘岳不群’, 1, ‘1993-7-19’, ‘陕西咸阳’, 1),<br>(1378, ‘纪嫣然’, 0, ‘1995-8-12’, ‘四川绵阳’, 1),<br>(1954, ‘林平之’, 1, ‘1994-9-20’, ‘福建莆田’, 1),<br>(2035, ‘东方不败’, 1, ‘1988-6-30’, null, 2),<br>(3011, ‘林震南’, 1, ‘1985-12-12’, ‘福建莆田’, 3),<br>(3755, ‘项少龙’, 1, ‘1993-1-25’, null, 3),<br>(3923, ‘杨不悔’, 0, ‘1985-4-17’, ‘四川成都’, 3);</p><pre><code>#### 6.插入老师数据</code></pre><p>insert into tb_teacher (teaid, tname, title, collid) values<br>(1122, ‘张三丰’, ‘教授’, 1),<br>(1133, ‘宋远桥’, ‘副教授’, 1),<br>(1144, ‘杨逍’, ‘副教授’, 1),<br>(2255, ‘范遥’, ‘副教授’, 2),<br>(3366, ‘韦一笑’, ‘讲师’, 3);</p><pre><code>#### 7. 插入课程数据</code></pre><p>insert into tb_course (couid, cname, credit, teaid) values<br>(1111, ‘Python程序设计’, 3, 1122),<br>(2222, ‘Web前端开发’, 2, 1122),<br>(3333, ‘操作系统’, 4, 1122),<br>(4444, ‘计算机网络’, 2, 1133),<br>(5555, ‘编译原理’, 4, 1144),<br>(6666, ‘算法和数据结构’, 3, 1144),<br>(7777, ‘经贸法语’, 3, 2255),<br>(8888, ‘成本会计’, 2, 3366),<br>(9999, ‘审计学’, 3, 3366);</p><pre><code>#### 8.插入选课数据</code></pre><p>insert into tb_score (sid, cid, seldate, mark) values<br>(1001, 1111, ‘2017-09-01’, 95),<br>(1001, 2222, ‘2017-09-01’, 87.5),<br>(1001, 3333, ‘2017-09-01’, 100),<br>(1001, 4444, ‘2018-09-03’, null),<br>(1001, 6666, ‘2017-09-02’, 100),<br>(1002, 1111, ‘2017-09-03’, 65),<br>(1002, 5555, ‘2017-09-01’, 42),<br>(1033, 1111, ‘2017-09-03’, 92.5),<br>(1033, 4444, ‘2017-09-01’, 78),<br>(1033, 5555, ‘2017-09-01’, 82.5),<br>(1572, 1111, ‘2017-09-02’, 78),<br>(1378, 1111, ‘2017-09-05’, 82),<br>(1378, 7777, ‘2017-09-02’, 65.5),<br>(2035, 7777, ‘2018-09-03’, 88),<br>(2035, 9999, curdate(now()), null),<br>(3755, 1111, date(now()), null),<br>(3755, 8888, date(now()), null),<br>(3755, 9999, ‘2017-09-01’, 92);</p><pre><code>### 相关sql语句练习-- **总结** 分组之前的筛选用where子句，分组之后的子句筛选用having。  - 查询所有学生信息</code></pre><p>select * from tb-student;</p><pre><code>  - 查询所有课程名称及学分(投影和别名)</code></pre><p>select cname as 课程名称,credit from tb_corse</p><pre><code>  - 查询所有女学生的姓名和出生日期(筛选)</code></pre><p>select sname,birth from tb_student where gender=0;</p><pre><code>  - 查询所有80后学生的姓名、性别和出生日期(筛选)</code></pre><p>select sname,case gender when 1 then ‘男’ when 2 then ‘女’ else then ‘未知’,birth where birth between ‘1980-1-1 ‘ and ‘1989-12-31’;</p><pre><code>  - 查询所有80后学生的姓名、性别和出生日期(筛选)，使用mysql中的分支函数</code></pre><p>select sname,if(gender,’男’,’女’),birth where birth between ‘1980-1-1 ‘ and ‘1989-12-31’;</p><pre><code>  - 查询名字有四个中文字符字符的学生学号和姓名,一个中文三个字节</code></pre><p>select stuid,sname from tb_student where length(sname)/3=4;</p><pre><code>  - 查询姓”杨“的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨%’</p><pre><code>  - 查询姓”杨“名字两个字的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨_’</p><pre><code>  - 查询姓”杨“名字三个字的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨__’</p><pre><code>  - 查询名字中有”不“字或“嫣”字的学生的姓名(模糊)</code></pre><p>select sname from tb)student where sname like ‘%不%’ or sname like ‘%嫣%’</p><pre><code>  - 查询没有录入家庭住址的学生姓名(空值)  更加的严谨</code></pre><p>select sname from tb_student where addr is null or addr=’’;</p><pre><code>  - 查询录入了家庭住址的学生姓名(空值) 摩根定律</code></pre><p>select sname from tb_student where addr is not null or addr&lt;&gt;’’;</p><pre><code>  - 查询学生选课的所有日期(去重)-- distinct</code></pre><p>select distinct seldate from tb_score</p><pre><code>  - 查询学生的家庭住址(去重)</code></pre><p>select distinct addr from tb_student where addr is not null and addr&lt;&gt;””;</p><pre><code>  - 查询男学生的姓名和生日按年龄从大到小排列(排序)-- 升序   asc 默认</code></pre><p>select sname,birth from tb_student where gender=1 order by birth;<br>select sname,birth from tb_student where gender=1 order by birth desc;<br>select sname,year(now())-year(birth) as 年龄 from tb_student where gender=1 order by 年龄 asc;</p><pre><code>  - 聚合函数 max min sum avg count  - 查询年龄最大的学生的出生日期(聚合函数)</code></pre><p>select min(birth) from tb_student;</p><p>selecr sname,birth from tb_student where birth=(select min(birth) from tb_student)</p><pre><code>  - 查询男女学生的人数(分组和聚合函数)</code></pre><p>select gender,count(gender) from tb_student group by gender;</p><pre><code>  - 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)</code></pre><p>select avg(mark) from tb_score where cid=1111;</p><pre><code>  - 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)</code></pre><p>select sid,avg(mark) from tb_sscore where sid=1001;</p><pre><code>  - 查询每个学生的学号和平均成绩(分组和聚合函数)</code></pre><p>select sid,avg(mark) from tb_score group by sid;</p><pre><code>  - 查询平均成绩大于等于90分的且学号为1,2,3开头的学生的学号和平均成绩</code></pre><p>select sid,avg(mark) as 平均分 from tb_score where 平均分&gt;90 and sid between 1000 and 3999 order by 平均分 desc;</p><pre><code>  - 查询年龄最大的学生的姓名(子查询) 把一个查询的结果当做另一个查询的一部分来使用</code></pre><p>select sname from tb_student where birth=(select min(birth) from tb_student);</p><pre><code>  - 查询年龄最大的学生姓名和年龄(子查询+运算)</code></pre><p>select sname,year(now())-year(birth) from tb_student where birth=(selct min(birth) from tb_student);</p><pre><code>  - 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)</code></pre><p>select sname from tb_student where stuid in(select sid from tb_score group by sid having count(sid)&gt;2)</p><pre><code>  - 查询学生姓名、课程名称以及成绩(链接查询) 链接查询时，如果不使用链接条件，将会产生笛卡尔积</code></pre><p>三表联查<br>select sname,cname,mark from tb_student inner join tb_score on sid=stuid inner jion tb_course on couid=cid limit 5 offset 15;</p><p>select sname,cname,mark from tb_student,tb_course,tb_score where stuid=sid and couid=cid order by sname,mark desc;</p><pre><code>  - 查询选课学生的姓名和平均成绩(子查询和连接查询)</code></pre><p>select sname,avgmark from tb_student as t1 inner join<br>(select sid,avg(mark) as avgmark from tb_score group by sid) as t2 where t1.stuid=t2.sid;</p><pre><code>  - 查询每个学生的姓名和选课数量(左外连接和子查询)</code></pre><p>select sname,ifnull(total,0),ifnull(avgmark,0) from tb_student as t1 left join (select sid,count(sid) as total,avg(mark) as avgmark from tb_score group by sid) as t2 on stuid=sid order by total<br><code>`</code><br>    (左表：多表查询时，写在前面的表称为左表left outer join，right outer join ，mysql不支持全外连接 ：full outer join<br>    – 左外连接，将左表不满足连接条件的记录也要查出来，不满足链表条件的的地方补null<br>    – 右外连接，将右表不满足连接条件的记录也要查出来，不满足链表条件的的地方补null<br>    – 内连接只能将满足条件的表链接起来，不满足的链接条件的不能查出)</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库操作-建表</title>
      <link href="/2018/12/26/shu-ju-ku-cao-zuo-1-jian-biao-yi-ji-cha-xun-lian-xi/"/>
      <url>/2018/12/26/shu-ju-ku-cao-zuo-1-jian-biao-yi-ji-cha-xun-lian-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1.创建数据库"></a>1.创建数据库</h3><p>– 如果存在srs的数据库就删除它（慎重），之后创建数据库并且进入数据库。</p><pre><code>drop database if exists srs;create database srs default charset utf8;use srs;</code></pre><h3 id="2-创建二维表"><a href="#2-创建二维表" class="headerlink" title="2.创建二维表"></a>2.创建二维表</h3><p>例子：创建学生管理表并且添加信息</p><h4 id="1-创建学员表"><a href="#1-创建学员表" class="headerlink" title="1.创建学员表"></a>1.创建学员表</h4><pre><code>create table tb_college(collid int not null auto_increment comment &#39;学院编号&#39;,collname varchar(50) not null comment &#39;学院名称&#39;,collmaster varchar(20) not null comment &#39;院长姓名&#39;,collweb varchar(511) default &#39;&#39; comment &#39;学院网站&#39;,primary key (collid));</code></pre><ul><li>添加唯一性约束到学院名称<pre><code>alter table tb_college add constraint uni_college_collname unique (collname);</code></pre><h4 id="2-创建学生表"><a href="#2-创建学生表" class="headerlink" title="2.创建学生表"></a>2.创建学生表</h4><pre><code>create table tb_student(stuid int not null comment &#39;学号&#39;,sname varchar(20) not null comment &#39;学生姓名&#39;,gender bit default 1 comment &#39;性别&#39;,birth date not null comment &#39;出生日期&#39;,addr varchar(255) default &#39;&#39; comment &#39;籍贯&#39;,collid int not null comment &#39;所属学院编号&#39;,primary key (stuid));</code></pre></li><li>检查约束，mysql不支持：<pre><code>alter table tb_student add constraint ck_student_birth check (birth between &#39;1990-1-1&#39; and &#39;1999-12-31&#39;);</code></pre></li><li>添加外键约束<pre><code>alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid);</code></pre><h4 id="3-创建教师表"><a href="#3-创建教师表" class="headerlink" title="3.创建教师表"></a>3.创建教师表</h4><pre><code>create table tb_teacher(teaid int not null comment &#39;教师工号&#39;,tname varchar(20) not null comment &#39;教师姓名&#39;,title varchar(10) default &#39;&#39; comment &#39;职称&#39;,collid int not null comment &#39;所属学院编号&#39;);</code></pre></li><li>添加外键约束<pre><code>alter table tb_teacher add constraint pk_teacher primary key (teaid);</code></pre></li><li>添加外键约束<pre><code>alter table tb_teacher add constraint fk_teacher_collid foreign key (collid) references tb_college (collid);</code></pre><h4 id="4-插入学院数据"><a href="#4-插入学院数据" class="headerlink" title="4.插入学院数据"></a>4.插入学院数据</h4></li><li>插入学院数据<br><code>`</code><br>insert into tb_college (collname, collmaster, collweb) values<br>(‘计算机学院’, ‘左冷禅’, ‘<a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> </li></ul><p>‘),<br>(‘外国语学院’, ‘岳不群’, ‘<a href="http://www.xyz.com" target="_blank" rel="noopener">http://www.xyz.com</a> </p><p>‘),<br>(‘经济管理学院’, ‘风清扬’, ‘<a href="http://www.foo.com" target="_blank" rel="noopener">http://www.foo.com</a> </p><p>‘);</p><pre><code>#### 5.插入学生数据</code></pre><p>insert into tb_student (stuid, sname, gender, birth, addr, collid) values<br>(1001, ‘杨逍’, 1, ‘1990-3-4’, ‘四川成都’, 1),<br>(1002, ‘任我行’, 1, ‘1992-2-2’, ‘湖南长沙’, 1),<br>(1033, ‘王语嫣’, 0, ‘1989-12-3’, ‘四川成都’, 1),<br>(1572, ‘岳不群’, 1, ‘1993-7-19’, ‘陕西咸阳’, 1),<br>(1378, ‘纪嫣然’, 0, ‘1995-8-12’, ‘四川绵阳’, 1),<br>(1954, ‘林平之’, 1, ‘1994-9-20’, ‘福建莆田’, 1),<br>(2035, ‘东方不败’, 1, ‘1988-6-30’, null, 2),<br>(3011, ‘林震南’, 1, ‘1985-12-12’, ‘福建莆田’, 3),<br>(3755, ‘项少龙’, 1, ‘1993-1-25’, null, 3),<br>(3923, ‘杨不悔’, 0, ‘1985-4-17’, ‘四川成都’, 3);</p><pre><code>#### 6.插入老师数据</code></pre><p>insert into tb_teacher (teaid, tname, title, collid) values<br>(1122, ‘张三丰’, ‘教授’, 1),<br>(1133, ‘宋远桥’, ‘副教授’, 1),<br>(1144, ‘杨逍’, ‘副教授’, 1),<br>(2255, ‘范遥’, ‘副教授’, 2),<br>(3366, ‘韦一笑’, ‘讲师’, 3);</p><pre><code>#### 7. 插入课程数据</code></pre><p>insert into tb_course (couid, cname, credit, teaid) values<br>(1111, ‘Python程序设计’, 3, 1122),<br>(2222, ‘Web前端开发’, 2, 1122),<br>(3333, ‘操作系统’, 4, 1122),<br>(4444, ‘计算机网络’, 2, 1133),<br>(5555, ‘编译原理’, 4, 1144),<br>(6666, ‘算法和数据结构’, 3, 1144),<br>(7777, ‘经贸法语’, 3, 2255),<br>(8888, ‘成本会计’, 2, 3366),<br>(9999, ‘审计学’, 3, 3366);</p><pre><code>#### 8.插入选课数据</code></pre><p>insert into tb_score (sid, cid, seldate, mark) values<br>(1001, 1111, ‘2017-09-01’, 95),<br>(1001, 2222, ‘2017-09-01’, 87.5),<br>(1001, 3333, ‘2017-09-01’, 100),<br>(1001, 4444, ‘2018-09-03’, null),<br>(1001, 6666, ‘2017-09-02’, 100),<br>(1002, 1111, ‘2017-09-03’, 65),<br>(1002, 5555, ‘2017-09-01’, 42),<br>(1033, 1111, ‘2017-09-03’, 92.5),<br>(1033, 4444, ‘2017-09-01’, 78),<br>(1033, 5555, ‘2017-09-01’, 82.5),<br>(1572, 1111, ‘2017-09-02’, 78),<br>(1378, 1111, ‘2017-09-05’, 82),<br>(1378, 7777, ‘2017-09-02’, 65.5),<br>(2035, 7777, ‘2018-09-03’, 88),<br>(2035, 9999, curdate(now()), null),<br>(3755, 1111, date(now()), null),<br>(3755, 8888, date(now()), null),<br>(3755, 9999, ‘2017-09-01’, 92);</p><pre><code>### 相关sql语句练习-- **总结** 分组之前的筛选用where子句，分组之后的子句筛选用having。  - 查询所有学生信息</code></pre><p>select * from tb-student;</p><pre><code>  - 查询所有课程名称及学分(投影和别名)</code></pre><p>select cname as 课程名称,credit from tb_corse</p><pre><code>  - 查询所有女学生的姓名和出生日期(筛选)</code></pre><p>select sname,birth from tb_student where gender=0;</p><pre><code>  - 查询所有80后学生的姓名、性别和出生日期(筛选)</code></pre><p>select sname,case gender when 1 then ‘男’ when 2 then ‘女’ else then ‘未知’,birth where birth between ‘1980-1-1 ‘ and ‘1989-12-31’;</p><pre><code>  - 查询所有80后学生的姓名、性别和出生日期(筛选)，使用mysql中的分支函数</code></pre><p>select sname,if(gender,’男’,’女’),birth where birth between ‘1980-1-1 ‘ and ‘1989-12-31’;</p><pre><code>  - 查询名字有四个中文字符字符的学生学号和姓名,一个中文三个字节</code></pre><p>select stuid,sname from tb_student where length(sname)/3=4;</p><pre><code>  - 查询姓”杨“的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨%’</p><pre><code>  - 查询姓”杨“名字两个字的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨_’</p><pre><code>  - 查询姓”杨“名字三个字的学生姓名和性别(模糊)</code></pre><p>select sname,if(gender,’男’,’女’) from tb_student where sname like ‘杨__’</p><pre><code>  - 查询名字中有”不“字或“嫣”字的学生的姓名(模糊)</code></pre><p>select sname from tb)student where sname like ‘%不%’ or sname like ‘%嫣%’</p><pre><code>  - 查询没有录入家庭住址的学生姓名(空值)  更加的严谨</code></pre><p>select sname from tb_student where addr is null or addr=’’;</p><pre><code>  - 查询录入了家庭住址的学生姓名(空值) 摩根定律</code></pre><p>select sname from tb_student where addr is not null or addr&lt;&gt;’’;</p><pre><code>  - 查询学生选课的所有日期(去重)-- distinct</code></pre><p>select distinct seldate from tb_score</p><pre><code>  - 查询学生的家庭住址(去重)</code></pre><p>select distinct addr from tb_student where addr is not null and addr&lt;&gt;””;</p><pre><code>  - 查询男学生的姓名和生日按年龄从大到小排列(排序)-- 升序   asc 默认</code></pre><p>select sname,birth from tb_student where gender=1 order by birth;<br>select sname,birth from tb_student where gender=1 order by birth desc;<br>select sname,year(now())-year(birth) as 年龄 from tb_student where gender=1 order by 年龄 asc;</p><pre><code>  - 聚合函数 max min sum avg count  - 查询年龄最大的学生的出生日期(聚合函数)</code></pre><p>select min(birth) from tb_student;</p><p>selecr sname,birth from tb_student where birth=(select min(birth) from tb_student)</p><pre><code>  - 查询男女学生的人数(分组和聚合函数)</code></pre><p>select gender,count(gender) from tb_student group by gender;</p><pre><code>  - 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)</code></pre><p>select avg(mark) from tb_score where cid=1111;</p><pre><code>  - 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)</code></pre><p>select sid,avg(mark) from tb_sscore where sid=1001;</p><pre><code>  - 查询每个学生的学号和平均成绩(分组和聚合函数)</code></pre><p>select sid,avg(mark) from tb_score group by sid;</p><pre><code>  - 查询平均成绩大于等于90分的且学号为1,2,3开头的学生的学号和平均成绩</code></pre><p>select sid,avg(mark) as 平均分 from tb_score where 平均分&gt;90 and sid between 1000 and 3999 order by 平均分 desc;</p><pre><code>  - 查询年龄最大的学生的姓名(子查询) 把一个查询的结果当做另一个查询的一部分来使用</code></pre><p>select sname from tb_student where birth=(select min(birth) from tb_student);</p><pre><code>  - 查询年龄最大的学生姓名和年龄(子查询+运算)</code></pre><p>select sname,year(now())-year(birth) from tb_student where birth=(selct min(birth) from tb_student);</p><pre><code>  - 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)</code></pre><p>select sname from tb_student where stuid in(select sid from tb_score group by sid having count(sid)&gt;2)</p><pre><code>  - 查询学生姓名、课程名称以及成绩(链接查询) 链接查询时，如果不使用链接条件，将会产生笛卡尔积</code></pre><p>三表联查<br>select sname,cname,mark from tb_student inner join tb_score on sid=stuid inner jion tb_course on couid=cid limit 5 offset 15;</p><p>select sname,cname,mark from tb_student,tb_course,tb_score where stuid=sid and couid=cid order by sname,mark desc;</p><pre><code>  - 查询选课学生的姓名和平均成绩(子查询和连接查询)</code></pre><p>select sname,avgmark from tb_student as t1 inner join<br>(select sid,avg(mark) as avgmark from tb_score group by sid) as t2 where t1.stuid=t2.sid;</p><pre><code>  - 查询每个学生的姓名和选课数量(左外连接和子查询)</code></pre><p>select sname,ifnull(total,0),ifnull(avgmark,0) from tb_student as t1 left join (select sid,count(sid) as total,avg(mark) as avgmark from tb_score group by sid) as t2 on stuid=sid order by total<br><code>`</code><br>    (左表：多表查询时，写在前面的表称为左表left outer join，right outer join ，mysql不支持全外连接 ：full outer join<br>    – 左外连接，将左表不满足连接条件的记录也要查出来，不满足链表条件的的地方补null<br>    – 右外连接，将右表不满足连接条件的记录也要查出来，不满足链表条件的的地方补null<br>    – 内连接只能将满足条件的表链接起来，不满足的链接条件的不能查出)</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基操</title>
      <link href="/2018/12/26/linux-zhuang-ruan-jian/"/>
      <url>/2018/12/26/linux-zhuang-ruan-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux安装软件"><a href="#Linux安装软件" class="headerlink" title="Linux安装软件"></a>Linux安装软件</h3><p><strong>docker</strong>：虚拟化服务，创建虚拟化容器，并安装软件</p><h4 id="1-包管理管理工具-yum、rpm"><a href="#1-包管理管理工具-yum、rpm" class="headerlink" title="1.包管理管理工具 -yum、rpm"></a>1.包管理管理工具 -yum、rpm</h4><ul><li>yum -y install docker-io   安装docker<ul><li>yum -y removie docker-io  卸载docker</li><li>yum info…    </li><li>yum search… </li><li>yum list installed | grep docker    查看docker中挂在的软件<h4 id="2-管理docker服务"><a href="#2-管理docker服务" class="headerlink" title="2.管理docker服务"></a>2.管理docker服务</h4></li></ul></li><li>systemctl start docker<ul><li>systemctl stop docker</li><li>systemctl restart docker</li><li>systemctl status docker   状态</li><li>systemctl enable docker</li><li>systemctl disable docker</li></ul></li></ul><p><strong>补充</strong>：<br><strong>Mysql数据库超级管理云账号 - root<br>Oracle数据库超级管理员账号 - sys<br>SQLServer数据库管理员账号 </strong></p><h4 id="3-阿里云中docker安装mysql5-7步骤"><a href="#3-阿里云中docker安装mysql5-7步骤" class="headerlink" title="3.阿里云中docker安装mysql5.7步骤"></a>3.阿里云中docker安装mysql5.7步骤</h4><p>  a 下载mysql的镜像文件：docker pull mysql：5.7<br>  b 查看已经下载的镜像文件:  docker images<br>  c 创建并运行容器:docker run -d -p 3306:3306 –name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7    (需要打开3306端口)<br>  d 安装MySQL客户端工具</p><pre><code>- navicat  -猫- SQLyog   -海豚- Toad for MySQL -蛤蟆</code></pre><h4 id="4-查看运行中的程序"><a href="#4-查看运行中的程序" class="headerlink" title="4.查看运行中的程序"></a>4.查看运行中的程序</h4><ul><li>docker ps<h4 id="5-查看所有的容器"><a href="#5-查看所有的容器" class="headerlink" title="5.查看所有的容器"></a>5.查看所有的容器</h4></li><li>docker container ls -a<h4 id="6-停止启动容器"><a href="#6-停止启动容器" class="headerlink" title="6.停止启动容器"></a>6.停止启动容器</h4></li><li>docker stop masql57<ul><li>docker start mysql57</li><li>docker restart mysql57<h4 id="7-删除容器"><a href="#7-删除容器" class="headerlink" title="7.删除容器"></a>7.删除容器</h4></li></ul></li><li>docker rm -f  mysql</li></ul><h3 id="Linux操作常识补充"><a href="#Linux操作常识补充" class="headerlink" title="Linux操作常识补充"></a>Linux操作常识补充</h3><p>1.将前台任务放到后台，且暂停   ctrl+z；<br>2.前台任务直接gg。                     ctrl+c；<br>3.查看网络端口；ip，                  netstat -nap | grep 3306<br>4.查看后台程序                        jobs<br>5.将后台程序在后台启动              bg %num，num是后台进程编号<br>6.man 命令既可以查询相关的方法 man netstat<br>7.info netstat</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yum </tag>
            
            <tag> rpm </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库知识1</title>
      <link href="/2018/12/26/shu-ju-ku-chang-shi/"/>
      <url>/2018/12/26/shu-ju-ku-chang-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><p>数据库是为了实现项目中的数据持久性 </p><h3 id="2-数据库的类型"><a href="#2-数据库的类型" class="headerlink" title="2.数据库的类型"></a>2.数据库的类型</h3><h4 id="2-1关系型数据库"><a href="#2-1关系型数据库" class="headerlink" title="2.1关系型数据库"></a>2.1关系型数据库</h4><ul><li>特点：<ul><li>1.理论基础：集合论和关系型代数</li><li>2.用二维表来阻止数据（行（记录）和列（字段））</li><li>3.SQL - 结构化查询语言</li><li>关系型数据库产品：</li><li>1.Oracle - 甲骨文</li><li>2.mysql  - 甲骨文 - MariaDB</li><li>3.DB2，SQLServer、PsotgreSQL、SQLite<br><strong>能够唯一标记一条记录的列成为主键（primary key）</strong></li><li>4.SQL - 结构化查询语言</li><li>DDL - 数据定义语言 - create，drop，alter</li><li>DML - 数据操作语言 - insert，delete，updata，select</li><li>DCL - 数据控制语言 - grant，revoke，commit，rollback<br> <strong>介绍两个关键词，crash course  和 best practice</strong></li></ul></li></ul><h4 id="2-2NoAQL非关系型数据库"><a href="#2-2NoAQL非关系型数据库" class="headerlink" title="2.2NoAQL非关系型数据库"></a>2.2NoAQL非关系型数据库</h4><ul><li>1.MongoDB - 文档数据库 - 适合大量但是价值低的数据库<ul><li>2.Redis - kv 数据库 - 性能好适合做高速缓存服务</li><li>3.ElsaticSearch - 搜索引擎</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>blog_setting介绍</title>
      <link href="/2018/12/22/blog-setting/"/>
      <url>/2018/12/22/blog-setting/</url>
      
        <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a>设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>每天动态切换<code>Banner</code>图片</li><li>瀑布流式的博客文章列表(文章无特色图片时会有<code>24</code>张漂亮的图片代替)</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持<code>MathJax</code></li><li><code>TOC</code>目录</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>和<a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>评论模块（推荐使用<code>Gitalk</code>）</li><li>集成了谷歌分析(<code>Google Analytics</code>)</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>博客了，Hexo 和<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a>来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的<code>_config.yml</code>的<code>theme</code>的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml文件的其它修改建议"><a href="#config-yml文件的其它修改建议" class="headerlink" title="_config.yml文件的其它修改建议:"></a><code>_config.yml</code>文件的其它修改建议:</h4><ul><li>请修改<code>_config.yml</code>的<code>url</code>的值为你的网站主<code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个<code>per_page</code>的分页条数值为<code>6</code>的倍数，如：<code>12</code>、<code>18</code>等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改<code>language</code>的值为<code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code>页是用来展示所有分类的页面，如果在你的博客<code>source</code>目录下还没有<code>categories/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code>页是用来展示所有标签的页面，如果在你的博客<code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code>页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客<code>source</code>目录下还没有<code>about/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code>页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客<code>source</code>目录下还没有<code>friends/index.md</code>文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑你刚刚新建的页面文件<code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在你的博客<code>source</code>目录下新建<code>_data</code>目录，在<code>_data</code>目录中新建<code>friends.json</code>文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"lorry——Python"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"Python_遇见那天的雨真大"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.jianshu.com/u/cf22212f3cdf"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去观摩"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a>的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增<code>prism</code>插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  <span class="token key atrule">custom_css</span><span class="token punctuation">:</span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了<a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于<code>SEO</code>，且<code>gitment</code>评论对中文链接也不支持。我们可以用<a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>插件也可以生成非中文的链接。</p></blockquote><h3 id="添加RSS订阅支持（可选的）"><a href="#添加RSS订阅支持（可选的）" class="headerlink" title="添加RSS订阅支持（可选的）"></a>添加RSS订阅支持（可选的）</h3><p>本主题中还使用到了<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>的 Hexo 插件来做<code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code>重新生成博客文件，然后在<code>public</code>文件夹中即可看到<code>atom.xml</code>文件，说明你已经安装成功了。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题文件的<code>/layout/_partial/social-link.ejs</code>文件中，你可以修改或添加你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a>中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的<code>Font Awesome</code>版本为<code>4.5.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的<code>source/medias/reward</code>文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h2 id="文档示例"><a href="#文档示例" class="headerlink" title="文档示例"></a>文档示例</h2><p>以下为文章<code>Front-matter</code>的示例，所有内容均为<strong>非必填</strong>的。但是，仍然建议至少填写<code>title</code>的值，当然最好都填写上这些文章信息。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg <span class="token comment" spellcheck="true"># 或者:http://xxx.com/xxx.jpg</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 如果top值为true，则会是首页推荐文章</span><span class="token comment" spellcheck="true"># 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破</span><span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token comment" spellcheck="true"># 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><p><strong>注意</strong>:</p><ol><li>如果<code>img</code>属性不填写的话，文章特色图会根据文章标题的<code>hashcode</code>的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code>的值尽量保证每篇文章是唯一的，因为本主题中<code>Gitalk</code>和<code>Gitment</code>识别<code>id</code>是通过<code>date</code>的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在Front-matter中设置采用了SHA256加密的password的值，还需要在主题的<code>_config.yml</code>中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的<code>_config.yml</code>中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>首页的励志名言</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC目录</li><li>文章打赏信息</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code>和<code>disqus</code>评论配置</li><li>谷歌分析(<code>Google Analytics</code>)</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的<code>hashcode</code>值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的<code>_config.yml</code>中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的<code>/source/css/matery.css</code>文件中，搜索<code>.bg-color</code>来修改背景颜色：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */</span><span class="token selector"><span class="token class">.text-color</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#0f9d58</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> blog搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git仓库管理</title>
      <link href="/2018/12/19/git-cao-zuo-cang-ku-guan-li/"/>
      <url>/2018/12/19/git-cao-zuo-cang-ku-guan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h3><p>Git是目前世界上最先进的分布式版本控制系统。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>现在，Git可以在Linux、Unix、Mac和Windows这<br>几大平台上正常运行了。<br>1.linux上安装Git<br>2.windows上安装Git<br>(<a href="https://git-scm.com/download/),然后一路默认。" target="_blank" rel="noopener">https://git-scm.com/download/),然后一路默认。</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="设定自己机器的全局变量"><a href="#设定自己机器的全局变量" class="headerlink" title="设定自己机器的全局变量"></a>设定自己机器的全局变量</h4><p> git config –global user.name “Your Name” —— 设定用户名字，随便写<br> git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“ ——设定用户邮箱，随便写<br>注意git config命令的–global参数，用了这个参数，表明你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h4 id="查看自己机器的配置信息"><a href="#查看自己机器的配置信息" class="headerlink" title="查看自己机器的配置信息"></a>查看自己机器的配置信息</h4><p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-&gt;global-&gt;local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件<br>git config –system –list——查看系统config<br>git config –global  –list——查看当前用户（global）配置<br>git config –local  –list—— 查看当前仓库配置信息<br>git config –list ——查看全配置</p><h4 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h4><p>git config –global color.ui true ——开启颜色支持<br>git config –global core.quotepath false ——支持utf-8编码</p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>git config –global –replace-all user.email “输入你的邮箱”<br>git config –global –replace-all user.name “输入你的用户名”</p><h3 id="创建版本库（repository）"><a href="#创建版本库（repository）" class="headerlink" title="创建版本库（repository）"></a>创建版本库（repository）</h3><p>mkdir directory——创建一个空目录<br>cd directory<br>windows下目录最好不用中文<br>git init——初始化仓库</p><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><p>git status</p><h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><p>touch ddf.txt<br>git add ddf.txt——把文件添加到缓存区<br>git add -A——添加所有文件到仓库<br>这里如果有警告则添加git config –global core.autocrlf false；原因是路径中存在 / 的符号转义问题，false就是不转换符号默认是true，相当于把路径的 / 符号进行转义，这样添加的时候就有问题。<br>git commit -m “first”——把文件提交到仓库<br>git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="回溯操作"><a href="#回溯操作" class="headerlink" title="回溯操作"></a>回溯操作</h3><p>git dif——查看difference，即查看修改内容<br>git log——查看提交历史，以便确定要回退到哪个版本。<br>记住：commit_id（版本号）<br>git reset –hard HEAD^——HEAD指向的版本就是当前版本，该指令即为回到上个操作版本<br>git reset –hard commit_id——回溯到相应版本<br>git reflog——查看命令历史，以便确定要回到未来的哪个版本。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p> git checkout – ddf.txt</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p> rm ddf.txt</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>git push——推送，第一次后即用<br>git push  -u origin master——第一次推送master分支的所有内容</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>1.通过https克隆<br>git clone url<br>2.通过ssh克隆</p><h3 id="从远程添加到本地"><a href="#从远程添加到本地" class="headerlink" title="从远程添加到本地"></a>从远程添加到本地</h3><p> git pull——拉</p>]]></content>
      
      
      <categories>
          
          <category> 仓库管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git仓库管理2</title>
      <link href="/2018/12/18/git-cao-zuo-cang-ku-guan-li-2/"/>
      <url>/2018/12/18/git-cao-zuo-cang-ku-guan-li-2/</url>
      
        <content type="html"><![CDATA[<h6 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h6><ol><li><p>克隆github或者码云上代码到本地</p><pre><code>git clone 分支名仓库名地址</code></pre><p>一般拉取下来的代码，当前分支都在master分支上</p></li><li><p>创建自己的分支</p><pre><code>git checkout -b wanghaifei</code></pre></li><li><p>查看当前修改文件的状态</p><pre><code>git status</code></pre></li><li><p>添加要上传的文件</p><pre><code>git add 修改后的文件</code></pre></li><li><p>提交添加文件的注解</p><pre><code>git commit -m &#39;注解&#39;</code></pre></li><li><p>文件到本地分支中</p><pre><code>git push origin wanghaifei</code></pre></li><li><p>合并添加上传文件和添加上传文件注解到本地分支的操作</p><pre><code>git commit -am &#39;注解&#39;</code></pre></li><li><p>下拉远程自己分支代码到本地自己分支</p><pre><code>git pull origin wanghaifei</code></pre></li></ol><hr><h6 id="代码分支合并，tag提交"><a href="#代码分支合并，tag提交" class="headerlink" title="代码分支合并，tag提交"></a>代码分支合并，tag提交</h6><ol start="9"><li><p>将自己分支代码合并到测试分支以便测试人员测试<br>先切换版本到dev分支</p><pre><code>git checkout dev</code></pre><p>当前dev分支在合并wanghaifei分支</p><pre><code>git merge wanghaifei</code></pre><p>提交dev分支合并的代码到远程dev分支上</p><pre><code>git push origin dev</code></pre></li><li><p>上线代码需要打tag，在master分支打tag<br>打版本v1.0.0.0</p><pre><code>git tag -a 版本号 -m &#39;注解&#39;</code></pre><p>提交版本v1.0.0.0</p><pre><code>git push origin v1.0.0.0</code></pre></li></ol><hr><h6 id="分支版本处理"><a href="#分支版本处理" class="headerlink" title="分支版本处理"></a>分支版本处理</h6><ol start="11"><li><p>删除本地分支</p><pre><code>git branch -D wanghaifei</code></pre></li><li><p>删除git远程分支</p><pre><code>git push origin --delete wanghaifei</code></pre></li><li><p>删除本地tag</p><pre><code>git tag -d v1.0.0.0</code></pre></li><li><p>删除git远程tag</p><pre><code>git push origin --delete tag v1.0.0.0</code></pre></li></ol><ol start="15"><li>查看dev分支和wanghaifei分支的不同<pre><code>git diff dev wanghaifei</code></pre></li></ol><hr><h6 id="缓存机制，在某一个分支修改了代码，但是不想提交该分支，又想切换到另外一个分支在修改相同的代码，就需要使用stash命令"><a href="#缓存机制，在某一个分支修改了代码，但是不想提交该分支，又想切换到另外一个分支在修改相同的代码，就需要使用stash命令" class="headerlink" title="缓存机制，在某一个分支修改了代码，但是不想提交该分支，又想切换到另外一个分支在修改相同的代码，就需要使用stash命令"></a>缓存机制，在某一个分支修改了代码，但是不想提交该分支，又想切换到另外一个分支在修改相同的代码，就需要使用stash命令</h6><ol start="16"><li><p>缓存本地修改的代码</p><pre><code>git stash</code></pre><p>缓存之后，在git status去查看修改代码记录会发现提示 nothing to commit，working tree clean。说明刚才修改的代码都缓存起来了</p></li><li><p>查看缓存的片段</p><pre><code>git stash list</code></pre><p>发现有缓存列表，刚才缓存的记录为 stash@{0}: XXXXXXXXXX</p></li><li><p>还原缓存的代码</p><pre><code>git stash apply stash@{0}</code></pre></li></ol><hr><h6 id="查看某次提交的详情，退回代码到某一次提交"><a href="#查看某次提交的详情，退回代码到某一次提交" class="headerlink" title="查看某次提交的详情，退回代码到某一次提交"></a>查看某次提交的详情，退回代码到某一次提交</h6><ol start="19"><li><p>查看提交的日志记录</p><pre><code>git log</code></pre><p>例如结果提交信息的日志如下：<br><code>`</code><br>commit f9838aa51ca5ccd603e1e8cbd347a43c9cd2e0be<br>Merge: f5847ec 52dc6fa<br>Author: wanghaifei <a href="mailto:&#55;&#x37;&#57;&#x35;&#x39;&#x38;&#x31;&#54;&#48;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#55;&#x37;&#57;&#x35;&#x39;&#x38;&#x31;&#54;&#48;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Mon Jan 29 17:15:34 2018 +0800</p><p>Merge branch ‘whf_p0’ into dev</p></li></ol><p>commit 52dc6fa34f36fae981d1c347825af93a150308fa<br>Author: wanghaifei <a href="mailto:&#x37;&#x37;&#57;&#x35;&#x39;&#x38;&#49;&#x36;&#48;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x37;&#x37;&#57;&#x35;&#x39;&#x38;&#49;&#x36;&#48;&#x40;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a><br>Date:   Mon Jan 29 17:15:22 2018 +0800</p><pre><code>完成预约增加预约到店时间</code></pre><pre><code>20. 查看某次提交的内容</code></pre><p>git show commit-id</p><pre><code>21. 退回代码回退到当前版本用HEAD表示当前版本，上一个版本是HEAD^,或者使用&lt;u&gt;HEAD~1&lt;/u&gt;，表示上一个版本。HEAD后面是数字可以一直往大了写，只要有那么多老版本</code></pre><p>git reset –hard<br><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> 仓库管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
